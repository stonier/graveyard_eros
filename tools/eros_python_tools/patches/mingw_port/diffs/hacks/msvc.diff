diff -r -x .svn tmp/msvc/core/roscpp/cmake/roscpp.cmake tmp/old/core/roscpp/cmake/roscpp.cmake
2d1
< rosbuild_find_ros_package(roscpp)
14c13
<     set(genmsg_cpp_exe ${roscpp_PACKAGE_PATH}/scripts/genmsg_cpp.py)
---
>     set(genmsg_cpp_exe ${genmsg_cpp_PACKAGE_PATH}/genmsg)
16c15
<     set(_output_cpp ${PROJECT_SOURCE_DIR}/msg_gen/cpp/include/${PROJECT_NAME}/${_msg})
---
>     set(_output_cpp ${PROJECT_SOURCE_DIR}/msg/cpp/${PROJECT_NAME}/${_msg})
28,32c27,28
<   # Make our target depend on rosbuild_premsgsrvgen, to allow any
<   # pre-msg/srv generation steps to be done first.
<   add_dependencies(ROSBUILD_genmsg_cpp rosbuild_premsgsrvgen)
<   # Add our target to the top-level rospack_genmsg target, which will be
<   # fired if the user calls genmsg()
---
>   # Add our target to the top-level genmsg target, which will be fired if
>   # the user calls genmsg()
49,50c45
<     set(gensrv_cpp_exe ${roscpp_PACKAGE_PATH}/scripts/gensrv_cpp.py)
<     set(genmsg_cpp_exe ${roscpp_PACKAGE_PATH}/scripts/genmsg_cpp.py)
---
>     set(gensrv_cpp_exe ${genmsg_cpp_PACKAGE_PATH}/gensrv)
52c47
<     set(_output_cpp ${PROJECT_SOURCE_DIR}/srv_gen/cpp/include/${PROJECT_NAME}/${_srv})
---
>     set(_output_cpp ${PROJECT_SOURCE_DIR}/srv/cpp/${PROJECT_NAME}/${_srv})
58c53
<                        DEPENDS ${_input} ${gensrv_cpp_exe} ${genmsg_cpp_exe} ${gendeps_exe} ${${PROJECT_NAME}_${_srv}_GENDEPS} ${ROS_MANIFEST_LIST})
---
>                        DEPENDS ${_input} ${gensrv_cpp_exe} ${gendeps_exe} ${${PROJECT_NAME}_${_srv}_GENDEPS} ${ROS_MANIFEST_LIST})
64,66d58
<   # Make our target depend on rosbuild_premsgsrvgen, to allow any
<   # pre-msg/srv generation steps to be done first.
<   add_dependencies(ROSBUILD_gensrv_cpp rosbuild_premsgsrvgen)
Only in tmp/msvc/core/roscpp/: cmake_win32
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/advertise_options.h tmp/old/core/roscpp/include/ros/advertise_options.h
32d31
< #include "ros/message_traits.h"
70d68
<   , has_header(false)
91,94c89,91
<     md5sum = message_traits::md5sum<M>();
<     datatype = message_traits::datatype<M>();
<     message_definition = message_traits::definition<M>();
<     has_header = message_traits::hasHeader<M>();
---
>     md5sum = M::__s_getMD5Sum();
>     datatype = M::__s_getDataType();
>     message_definition = M::__s_getMessageDefinition();
119c116
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
127,132d123
<   /** \brief Tells whether or not the message has a header.  If it does, the sequence number will be written directly into the
<    *         serialized bytes after the message has been serialized.
<    */
<   bool has_header;
< 
< 
150c141
<                           const VoidConstPtr& tracked_object,
---
>                           const VoidPtr& tracked_object,
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/advertise_service_options.h tmp/old/core/roscpp/include/ros/advertise_service_options.h
32,34c32
< #include "ros/service_callback_helper.h"
< #include "ros/service_traits.h"
< #include "ros/message_traits.h"
---
> #include "ros/service_message_helper.h"
49a48,62
>    * \brief Constructor
>    * \param _service Service name to advertise on
>    * \param _helper Helper object used for creating messages and calling callbacks
>    */
>   AdvertiseServiceOptions(const std::string& _service, const ServiceMessageHelperPtr& _helper)
>   : service(_service)
>   , md5sum(_helper->getMD5Sum())
>   , datatype(_helper->getDataType())
>   , req_datatype(_helper->getRequestDataType())
>   , res_datatype(_helper->getResponseDataType())
>   , helper(_helper)
>   , callback_queue(0)
>   {}
> 
>   /**
57,59c70
<     namespace st = service_traits;
<     namespace mt = message_traits;
<     if (st::md5sum<MReq>() != st::md5sum<MRes>())
---
>     if (MReq::__s_getServerMD5Sum() != MRes::__s_getServerMD5Sum())
61c72
<       ROS_FATAL("the request and response parameters to the server "
---
>       ROS_FATAL("woah! the request and response parameters to the server "
70,74c81,85
<     md5sum = st::md5sum<MReq>();
<     datatype = st::datatype<MReq>();
<     req_datatype = mt::datatype<MReq>();
<     res_datatype = mt::datatype<MRes>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<ServiceSpec<MReq, MRes> >(_callback));
---
>     md5sum = MReq::__s_getServerMD5Sum();
>     datatype = MReq::__s_getServiceDataType();
>     req_datatype = MReq::__s_getDataType();
>     res_datatype = MRes::__s_getDataType();
>     helper = ServiceMessageHelperPtr(new ServiceMessageHelperT<MReq, MRes>(_callback));
85,86d95
<     namespace st = service_traits;
<     namespace mt = message_traits;
90,114c99,103
<     md5sum = st::md5sum<Service>();
<     datatype = st::datatype<Service>();
<     req_datatype = mt::datatype<Request>();
<     res_datatype = mt::datatype<Response>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<ServiceSpec<Request, Response> >(_callback));
<   }
< 
<   /**
<    * \brief Templated convenience method for filling out md5sum/etc. based on the service spec type
<    * \param _service Service name to advertise on
<    * \param _callback Callback to call when this service is called
<    */
<   template<class Spec>
<   void initBySpecType(const std::string& _service, const typename Spec::CallbackType& _callback)
<   {
<     namespace st = service_traits;
<     namespace mt = message_traits;
<     typedef typename Spec::RequestType Request;
<     typedef typename Spec::ResponseType Response;
<     service = _service;
<     md5sum = st::md5sum<Request>();
<     datatype = st::datatype<Request>();
<     req_datatype = mt::datatype<Request>();
<     res_datatype = mt::datatype<Response>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<Spec>(_callback));
---
>     md5sum = Service::getMD5Sum();
>     datatype = Service::getDataType();
>     req_datatype = Request::__s_getDataType();
>     res_datatype = Request::__s_getDataType();
>     helper = ServiceMessageHelperPtr(new ServiceMessageHelperT<Request, Response>(_callback));
123c112
<   ServiceCallbackHelperPtr helper;                                     ///< Helper object used for creating messages and calling callbacks
---
>   ServiceMessageHelperPtr helper;                                     ///< Helper object used for creating messages and calling callbacks
137c126
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
149c138
<                                  const VoidConstPtr& tracked_object,
---
>                                  const VoidPtr& tracked_object,
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/callback_queue.h tmp/old/core/roscpp/include/ros/callback_queue.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
50,52d47
< #include <deque>
< 
< #include "ros/defines.h"
60c55
< class ROS_EXPORT CallbackQueue : public CallbackQueueInterface
---
> class CallbackQueue : public CallbackQueueInterface
69,76d63
<   enum CallOneResult
<   {
<     Called,
<     TryAgain,
<     Disabled,
<     Empty,
<   };
< 
81c68
<   CallOneResult callOne()
---
>   void callOne()
83c70
<     return callOne(ros::WallDuration());
---
>     callOne(ros::WallDuration());
94c81
<   CallOneResult callOne(ros::WallDuration timeout);
---
>   void callOne(ros::WallDuration timeout);
141,143d127
<   struct TLS;
<   CallOneResult callOneCB(TLS* tls);
< 
165,167c149
<   typedef std::deque<CallbackInfo> D_CallbackInfo;
<   D_CallbackInfo callbacks_;
<   size_t calling_;
---
>   L_CallbackInfo callbacks_;
178d159
<     , cb_it(callbacks.end())
181,182c162
<     D_CallbackInfo callbacks;
<     D_CallbackInfo::iterator cb_it;
---
>     L_CallbackInfo callbacks;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/callback_queue_interface.h tmp/old/core/roscpp/include/ros/callback_queue_interface.h
40c40
< #include "ros/types.h"
---
> #include "types.h"
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/common.h tmp/old/core/roscpp/include/ros/common.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33d30
< #ifndef WIN32
35d31
< #endif //WIN32
42d37
< #include "ros/serialized_message.h"
46,47d40
< #include "ros/defines.h"
< 
49,50c42,43
< #define ROS_VERSION_MINOR 2
< #define ROS_VERSION_PATCH 1
---
> #define ROS_VERSION_MINOR 0
> #define ROS_VERSION_PATCH 0
60c53,68
< void ROS_EXPORT disableAllSignalsInThisThread();
---
> void disableAllSignalsInThisThread();
> 
> class SerializedMessage
> {
> public:
>   boost::shared_array<uint8_t> buf;
>   size_t num_bytes;
> 
>   SerializedMessage()
>   : buf(boost::shared_array<uint8_t>())
>   , num_bytes(0)
>   {}
> 
>   SerializedMessage(boost::shared_array<uint8_t> buf, size_t num_bytes)
>   : buf(buf), num_bytes(num_bytes) { }
> };
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/connection.h tmp/old/core/roscpp/include/ros/connection.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
50,51d47
< #include "ros/defines.h"
< 
72c68
< class ROS_EXPORT Connection : public boost::enable_shared_from_this<Connection>
---
> class Connection : public boost::enable_shared_from_this<Connection>
75,81d70
<   enum DropReason
<   {
<     TransportDisconnect,
<     HeaderError,
<     Destructing,
<   };
< 
93c82
<   void drop(DropReason reason);
---
>   void drop();
101,105d89
<    * \brief Returns true if we're currently sending a header error (and will be automatically dropped when it's finished)
<    */
<   bool isSendingHeaderError() { return sending_header_error_; }
< 
<   /**
149,150c133,134
<   typedef boost::signal<void(const ConnectionPtr&, DropReason reason)> DropSignal;
<   typedef boost::function<void(const ConnectionPtr&, DropReason reason)> DropFunc;
---
>   typedef boost::signal<void(const ConnectionPtr&)> DropSignal;
>   typedef boost::function<void(const ConnectionPtr&)> DropFunc;
155d138
<   void removeDropListener(const boost::signals::connection& c);
171,176d153
<   /**
<    * \brief Set the Header associated with this connection (used with UDPROS, 
<    *        which receives the connection during XMLRPC negotiation).
<    */
<   void setHeader(const Header& header) { header_ = header; }
< 
221a199,205
>   /**
>    * If there is data available to read, we always try to read into our fixed read buffer, even if a read request
>    * has not been made.
>    */
>   uint8_t fixed_read_buffer_[READ_BUFFER_SIZE];
>   uint32_t fixed_read_filled_;
> 
265,267d248
< 
<   /// If we're sending a header error we disable most other calls
<   bool sending_header_error_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/connection_manager.h tmp/old/core/roscpp/include/ros/connection_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
31d28
< #include "connection.h"
36,37d32
< #include "ros/defines.h"
< 
65c60
<   void clear(Connection::DropReason reason);
---
>   void clear();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/exceptions.h tmp/old/core/roscpp/include/ros/exceptions.h
31c31
< #include <ros/exception.h>
---
> #include <stdexcept>
36a37,47
>  * \brief Base class for all exceptions thrown by roscpp
>  */
> class Exception : public std::runtime_error
> {
> public:
>   Exception(const std::string& what)
>   : std::runtime_error(what)
>   {}
> };
> 
> /**
59,91d69
< /**
<  * \brief Thrown when a second (third,...) subscription is attempted with conflicting
<  * arguments.
<  */
< class ConflictingSubscriptionException : public ros::Exception
< {
< public:
<   ConflictingSubscriptionException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
< 
< /**
<  * \brief Thrown when an invalid parameter is passed to a method
<  */
< class InvalidParameterException : public ros::Exception
< {
< public:
<   InvalidParameterException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
< 
< /**
<  * \brief Thrown when an invalid port is specified
<  */
< class InvalidPortException : public ros::Exception
< {
< public:
<   InvalidPortException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/file_log.h tmp/old/core/roscpp/include/ros/file_log.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
59c55
<         ROSCONSOLE_PRINT_AT_LOCATION(__VA_ARGS__); \
---
>         ros::console::print( loc.logger_, *loc.log4cxx_level_, LOG4CXX_LOCATION, __VA_ARGS__); \
63c59
<         ros::console::print(0, logger, ros::console::levels::Debug, __FILE__, __LINE__, __ROSCONSOLE_FUNCTION__, __VA_ARGS__); \
---
>         ros::console::print(logger, ros::file_log::getDebugLevel(), LOG4CXX_LOCATION, __VA_ARGS__); \
76,77c72,73
< const ROS_EXPORT std::string& getLogFilename();
< const ROS_EXPORT std::string& getLogDirectory();
---
> const std::string& getLogFilename();
> const std::string& getLogDirectory();
79,80c75,76
< ROS_EXPORT log4cxx::LoggerPtr& getFileOnlyLogger();
< ROS_EXPORT log4cxx::LevelPtr getDebugLevel();
---
> log4cxx::LoggerPtr& getFileOnlyLogger();
> log4cxx::LevelPtr getDebugLevel();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/forwards.h tmp/old/core/roscpp/include/ros/forwards.h
42c42
< #include "roscpp_macros.h"
---
> #include "macros.h"
50,51d49
< typedef boost::shared_ptr<void const> VoidConstPtr;
< typedef boost::weak_ptr<void const> VoidConstWPtr;
109c107
<                       const VoidConstPtr& tracked_object = VoidConstPtr(),
---
>                       const VoidPtr& tracked_object = VoidPtr(),
126c124
<   VoidConstWPtr tracked_object_;
---
>   VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/header.h tmp/old/core/roscpp/include/ros/header.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
40d37
< #ifndef WIN32
42,44d38
< #endif //WIN32
< 
< #include "ros/types.h"
51,52d44
< #include "ros/defines.h"
< 
65c57
< class ROS_EXPORT Header
---
> class Header
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/init.h tmp/old/core/roscpp/include/ros/init.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43,44d40
< #include "ros/defines.h"
< 
86c82
< ROS_EXPORT void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
---
> void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
96c92
< ROS_EXPORT void init(const M_string& remappings, const std::string& name, uint32_t options = 0);
---
> void init(const M_string& remappings, const std::string& name, uint32_t options = 0);
106c102
< ROS_EXPORT void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0);
---
> void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0);
111c107
< ROS_EXPORT bool isInitialized();
---
> bool isInitialized();
115c111
< ROS_EXPORT bool isShuttingDown();
---
> bool isShuttingDown();
127c123
< ROS_EXPORT void spin();
---
> void spin();
141c137
< ROS_EXPORT void spin(Spinner& spinner);
---
> void spin(Spinner& spinner);
150c146
< ROS_EXPORT void spinOnce();
---
> void spinOnce();
155c151
< ROS_EXPORT void waitForShutdown();
---
> void waitForShutdown();
163c159
< ROS_EXPORT bool ok();
---
> bool ok();
170c166
< ROS_EXPORT void shutdown();
---
> void shutdown();
177c173
< ROS_EXPORT void requestShutdown();
---
> void requestShutdown();
187c183
< ROS_EXPORT void start();
---
> void start();
191c187
< ROS_EXPORT bool isStarted();
---
> bool isStarted();
199c195
< ROS_EXPORT CallbackQueue* getGlobalCallbackQueue();
---
> CallbackQueue* getGlobalCallbackQueue();
209c205
< ROS_EXPORT void removeROSArgs(int argc, const char* const* argv, V_string& args_out);
---
> void removeROSArgs(int argc, const char** argv, V_string& args_out);
Only in tmp/msvc/core/roscpp/include/ros: internal_timer_manager.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/intraprocess_publisher_link.h tmp/old/core/roscpp/include/ros/intraprocess_publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,38d32
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
< 
52c46
< class ROS_EXPORT IntraProcessPublisherLink : public PublisherLink
---
> class IntraProcessPublisherLink : public PublisherLink
66,68c60
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy);
< 
<   void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes);
73d64
<   boost::recursive_mutex drop_mutex_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/intraprocess_subscriber_link.h tmp/old/core/roscpp/include/ros/intraprocess_subscriber_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,37d31
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
< 
47c41
< class ROS_EXPORT IntraProcessSubscriberLink : public SubscriberLink
---
> class IntraProcessSubscriberLink : public SubscriberLink
56c50,51
<   virtual void enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual bool publish(const Message& m);
>   virtual void enqueueMessage(const SerializedMessage& m);
59,60d53
<   virtual bool isIntraprocess() { return true; }
<   virtual void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
65d57
<   boost::recursive_mutex drop_mutex_;
Only in tmp/old/core/roscpp/include/ros: macros.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/master.h tmp/old/core/roscpp/include/ros/master.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
57c53
< ROS_EXPORT bool execute(const std::string& method, const XmlRpc::XmlRpcValue& request, XmlRpc::XmlRpcValue& response, XmlRpc::XmlRpcValue& payload, bool wait_for_master);
---
> bool execute(const std::string& method, const XmlRpc::XmlRpcValue& request, XmlRpc::XmlRpcValue& response, XmlRpc::XmlRpcValue& payload, bool wait_for_master);
63c59
< const ROS_EXPORT std::string& getHost();
---
> const std::string& getHost();
68c64
< ROS_EXPORT uint32_t getPort();
---
> uint32_t getPort();
72c68
< const ROS_EXPORT std::string& getURI();
---
> const std::string& getURI();
83c79
< ROS_EXPORT bool check();
---
> bool check();
91c87
<   TopicInfo(const std::string& _name, const std::string& _datatype /*, const std::string& _md5sum*/)
---
>   TopicInfo(const std::string& _name, const std::string& _datatype, const std::string& _md5sum)
94c90
<   //, md5sum(_md5sum)
---
>   , md5sum(_md5sum)
98,100c94
< 
<   // not possible yet unfortunately (master does not have this information)
<   //std::string md5sum;      ///< md5sum of the topic
---
>   std::string md5sum;      ///< md5sum of the topic
116c110
< ROS_EXPORT bool getTopics(V_TopicInfo& topics);
---
> bool getTopics(V_TopicInfo& topics);
121c115
< ROS_EXPORT bool getNodes(V_string& nodes);
---
> bool getNodes(V_string& nodes);
127,133c121
< ROS_EXPORT void setRetryTimeout(ros::WallDuration timeout);
< 
< #ifdef WIN32
< ROS_EXPORT void setURI(const std::string uri);
< ROS_EXPORT void setHost(const std::string host);
< ROS_EXPORT void setPort(const uint32_t port);
< #endif //WIN32
---
> void setRetryTimeout(ros::WallDuration timeout);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/message_deserializer.h tmp/old/core/roscpp/include/ros/message_deserializer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "forwards.h"
---
> #include "subscription_message_helper.h"
35d32
< #include <ros/serialized_message.h>
40,41d36
< #include "ros/defines.h"
< 
45,48c40
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT MessageDeserializer
---
> class MessageDeserializer
51c43
<   MessageDeserializer(const SubscriptionCallbackHelperPtr& helper, const SerializedMessage& m, const boost::shared_ptr<M_string>& connection_header);
---
>   MessageDeserializer(const SubscriptionMessageHelperPtr& helper, const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header);
53,54c45
<   VoidConstPtr deserialize();
<   const boost::shared_ptr<M_string>& getConnectionHeader() { return connection_header_; }
---
>   MessagePtr deserialize();
57,58c48,51
<   SubscriptionCallbackHelperPtr helper_;
<   SerializedMessage serialized_message_;
---
>   SubscriptionMessageHelperPtr helper_;
>   boost::shared_array<uint8_t> buffer_;
>   uint32_t num_bytes_;
>   bool buffer_includes_size_header_;
62c55
<   VoidConstPtr msg_;
---
>   MessagePtr msg_;
Only in tmp/msvc/core/roscpp/include/ros: message_event.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/message.h tmp/old/core/roscpp/include/ros/message.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "roscpp_macros.h"
---
> #include "macros.h"
39d36
< #ifndef WIN32
41d37
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/names.h tmp/old/core/roscpp/include/ros/names.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
49c45
< ROS_EXPORT std::string clean(const std::string& name);
---
> std::string clean(const std::string& name);
59c55
< ROS_EXPORT std::string resolve(const std::string& name, bool remap = true);
---
> std::string resolve(const std::string& name, bool remap = true);
70c66
< ROS_EXPORT std::string resolve(const std::string& ns, const std::string& name, bool remap = true);
---
> std::string resolve(const std::string& ns, const std::string& name, bool remap = true);
74c70
< ROS_EXPORT std::string append(const std::string& left, const std::string& right);
---
> std::string append(const std::string& left, const std::string& right);
79c75
< ROS_EXPORT std::string remap(const std::string& name);
---
> std::string remap(const std::string& name);
83c79
< ROS_EXPORT bool validate(const std::string& name, std::string& error);
---
> bool validate(const std::string& name, std::string& error);
85,86c81,82
< const ROS_EXPORT M_string& getRemappings();
< const ROS_EXPORT M_string& getUnresolvedRemappings();
---
> const M_string& getRemappings();
> const M_string& getUnresolvedRemappings();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/network.h tmp/old/core/roscpp/include/ros/network.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
46,51c42,43
< ROS_EXPORT bool splitURI(const std::string& uri, std::string& host, uint32_t& port);
< const ROS_EXPORT std::string& getHost();
< ROS_EXPORT uint16_t getTCPROSPort();
< #ifdef WIN32
< ROS_EXPORT void setHost( const std::string host);
< #endif //WIN32
---
> bool splitURI(const std::string& uri, std::string& host, uint32_t& port);
> const std::string& getHost();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/node_handle.h tmp/old/core/roscpp/include/ros/node_handle.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
39a38,39
> #include "ros/subscription_message_helper.h"
> #include "ros/service_message_helper.h"
53,54d52
< #include "ros/defines.h"
< 
85c83
< class ROS_EXPORT NodeHandle
---
> class NodeHandle
269c267
<                             const VoidConstPtr& tracked_object = VoidConstPtr(),
---
>                             const VoidPtr& tracked_object = VoidPtr(),
325,372d322
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Member function pointer to call when a message has arrived
<    * \param obj Object to call fp on
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class T>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for class member function with bare pointer
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using member functions, and can be used like so:
< \verbatim
< void Foo::callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< Foo foo_object;
< ros::Subscriber sub = handle.subscribe("my_topic", 1, &Foo::callback, &foo_object);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
389d338
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
419,468d367
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Member function pointer to call when a message has arrived
<    * \param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr
<    * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class T>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));
<     ops.tracked_object = obj;
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for class member function with shared_ptr
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using member functions on a shared_ptr:
< \verbatim
< void Foo::callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< boost::shared_ptr<Foo> foo_object(new Foo);
< ros::Subscriber sub = handle.subscribe("my_topic", 1, &Foo::callback, foo_object);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
486d384
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
516,561d413
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Function pointer to call when a message has arrived
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, fp);
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for bare function
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using bare functions, and can be used like so:
< \verbatim
< void callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< ros::Subscriber sub = handle.subscribe("my_topic", 1, callback);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
577d428
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
583c434
<     ops.template init<M>(topic, queue_size, fp);
---
>     ops.template init<M>(topic, queue_size, boost::function<void(const boost::shared_ptr<M>&)>(fp));
599d449
<    * \param M [template] M here is the message type
620d469
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
624c473
<                              const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())
---
>                              const VoidPtr& tracked_object = VoidPtr(), const TransportHints& transport_hints = TransportHints())
634,679d482
<    * \brief Subscribe to a topic, version for arbitrary boost::function object
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, callback is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe allows anything bindable to a boost::function object
<    *
<    * \param M [template] the message type
<    * \param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param callback Callback to call when a message has arrived
<    * \param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,
<    * and if the reference count goes to 0 the subscriber callbacks will not get called.
<    * Note that setting this will cause a new reference to be added to the object before the
<    * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore
<    * thread) that the callback is invoked from.
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class C>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,
<                              const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<C>(topic, queue_size, callback);
<     ops.tracked_object = tracked_object;
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
700d502
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
746,783d547
<    * \brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using member functions, and can be used like so:
< \verbatim
< bool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)
< {
<   return true;
< }
< 
< Foo foo_object;
< ros::ServiceServer service = handle.advertiseService("my_service", &Foo::callback, &foo_object);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func Member function pointer to call when a message has arrived
<    * \param obj Object to call srv_func on
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name
<    */
<   template<class T, class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));
<     return advertiseService(ops);
<   }
< 
<   /**
824,863d587
<    * \brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using member functions on shared pointers, and can be used like so:
< \verbatim
< bool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)
< {
<   return true;
< }
< 
< boost::shared_ptr<Foo> foo_object(new Foo);
< ros::ServiceServer service = handle.advertiseService("my_service", &Foo::callback, foo_object);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func Member function pointer to call when a message has arrived
<    * \param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,
<    * and if the object is deleted the service callback will stop being called (and therefore will not crash).
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class T, class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));
<     ops.tracked_object = obj;
<     return advertiseService(ops);
<   }
< 
<   /**
895,931c619
<     ops.template init<MReq, MRes>(service, srv_func);
<     return advertiseService(ops);
<   }
< 
<   /**
<    * \brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using bare functions, and can be used like so:
< \verbatim
< bool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)
< {
<   return true;
< }
< 
< ros::ServiceServer service = handle.advertiseService("my_service", callback);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func function pointer to call when a message has arrived
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);
---
>     ops.template init<MReq, MRes>(service, boost::function<bool(MReq&, MRes&)>(srv_func));
962c650
<   ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, const VoidConstPtr& tracked_object = VoidConstPtr())
---
>   ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, const VoidPtr& tracked_object = VoidPtr())
971,1007d658
<    * \brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type
<    *
<    * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything
<    * else boost::function supports).
<    *
<    * \param service Service name to advertise on
<    * \param callback Callback to call when the service is called
<    * \param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,
<    * and if the reference count goes to 0 the subscriber callbacks will not get called.
<    * Note that setting this will cause a new reference to be added to the object before the
<    * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore
<    * thread) that the callback is invoked from.
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class S>
<   ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, const VoidConstPtr& tracked_object = VoidConstPtr())
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<S>(service, callback);
<     ops.tracked_object = tracked_object;
<     return advertiseService(ops);
<   }
< 
<   /**
1095,1112d745
<   Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, bool oneshot = false) const
<   {
<     return createTimer(period, boost::bind(callback, obj, _1), oneshot);
<   }
< 
<   /**
<    * \brief Create a timer which will call a callback at the specified rate.  This variant takes
<    * a class member function, and a bare pointer to the object to call the method on.
<    *
<    * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically
<    * be stopped, and the callback will no longer be called.
<    *
<    * \param period The period at which to call the callback
<    * \param callback The method to call
<    * \param obj The object to call the method on
<    * \param oneshot If true, this timer will only fire once
<    */
<   template<class T>
1470a1104,1115
> 
>   /** \brief Get the hostname where the master runs.
>    *
>    * \return The master's hostname, as a string
>    */
>   const std::string &getMasterHost() const;
>   /** \brief Get the port where the master runs.
>    *
>    * \return The master's port.
>    */
>   int getMasterPort() const;
> 
Only in tmp/msvc/core/roscpp/include/ros: parameter_adapter.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/param.h tmp/old/core/roscpp/include/ros/param.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
53c49
< ROS_EXPORT void set(const std::string& key, const XmlRpc::XmlRpcValue& v);
---
> void set(const std::string& key, const XmlRpc::XmlRpcValue& v);
60c56
< ROS_EXPORT void set(const std::string& key, const std::string& s);
---
> void set(const std::string& key, const std::string& s);
67c63
< ROS_EXPORT void set(const std::string& key, const char* s);
---
> void set(const std::string& key, const char* s);
74c70
< ROS_EXPORT void set(const std::string& key, double d);
---
> void set(const std::string& key, double d);
81c77
< ROS_EXPORT void set(const std::string& key, int i);
---
> void set(const std::string& key, int i);
88c84
< ROS_EXPORT void set(const std::string& key, bool b);
---
> void set(const std::string& key, bool b);
98c94
< ROS_EXPORT bool get(const std::string& key, std::string& s);
---
> bool get(const std::string& key, std::string& s);
107c103
< ROS_EXPORT bool get(const std::string& key, double& d);
---
> bool get(const std::string& key, double& d);
116c112
< ROS_EXPORT bool get(const std::string& key, int& i);
---
> bool get(const std::string& key, int& i);
125c121
< ROS_EXPORT bool get(const std::string& key, bool& b);
---
> bool get(const std::string& key, bool& b);
134c130
< ROS_EXPORT bool get(const std::string& key, XmlRpc::XmlRpcValue& v);
---
> bool get(const std::string& key, XmlRpc::XmlRpcValue& v);
149c145
< ROS_EXPORT bool getCached(const std::string& key, std::string& s);
---
> bool getCached(const std::string& key, std::string& s);
163c159
< ROS_EXPORT bool getCached(const std::string& key, double& d);
---
> bool getCached(const std::string& key, double& d);
177c173
< ROS_EXPORT bool getCached(const std::string& key, int& i);
---
> bool getCached(const std::string& key, int& i);
191c187
< ROS_EXPORT bool getCached(const std::string& key, bool& b);
---
> bool getCached(const std::string& key, bool& b);
205c201
< ROS_EXPORT bool getCached(const std::string& key, XmlRpc::XmlRpcValue& v);
---
> bool getCached(const std::string& key, XmlRpc::XmlRpcValue& v);
214c210
< ROS_EXPORT bool has(const std::string& key);
---
> bool has(const std::string& key);
222c218
< ROS_EXPORT bool del(const std::string& key);
---
> bool del(const std::string& key);
238c234
< ROS_EXPORT bool search(const std::string& ns, const std::string& key, std::string& result);
---
> bool search(const std::string& ns, const std::string& key, std::string& result);
254c250
< ROS_EXPORT bool search(const std::string& key, std::string& result);
---
> bool search(const std::string& key, std::string& result);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/poll_manager.h tmp/old/core/roscpp/include/ros/poll_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
40,41d37
< #include "ros/defines.h"
< 
50c46
< class ROS_EXPORT PollManager
---
> class PollManager
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/poll_set.h tmp/old/core/roscpp/include/ros/poll_set.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
42d39
< #ifndef WIN32
44d40
< #endif //WIN32
50,51d45
< #include "ros/defines.h"
< 
64c58
< class ROS_EXPORT PollSet
---
> class PollSet
149,152d142
<   boost::mutex just_deleted_mutex_;
<   typedef std::vector<int> V_int;
<   V_int just_deleted_;
< 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publication.h tmp/old/core/roscpp/include/ros/publication.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45,46d42
< #include "ros/defines.h"
< 
57c53
< class ROS_EXPORT Publication
---
> class Publication
65,66c61
<             bool latch,
<             bool has_header);
---
>             bool latch);
93c88
<   bool hasSubscribers();
---
>   bool hasSubscribers() { return !subscriber_links_.empty(); }
97,99c92
<   uint32_t getNumSubscribers();
< 
<   void getPublishTypes(bool& serialize, bool& nocopy, const std::type_info& ti);
---
>   int getNumSubscribers() { return (int)subscriber_links_.size(); }
122,123d114
<   bool isLatched() { return latch_; }
< 
142c133
<   uint32_t incrementSequence();
---
>   void incrementSequence() { ++seq_; }
148,152d138
<   void publish(SerializedMessage& m);
<   void processPublishQueue();
< 
<   bool validateHeader(const Header& h, std::string& error_msg);
< 
171d156
<   boost::mutex seq_mutex_;
184d168
<   bool has_header_;
186,191d169
< 
<   uint32_t intraprocess_subscriber_count_;
< 
<   typedef std::vector<SerializedMessage> V_SerializedMessage;
<   V_SerializedMessage publish_queue_;
<   boost::mutex publish_queue_mutex_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publisher.h tmp/old/core/roscpp/include/ros/publisher.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34d31
< #include "ros/common.h"
36,39d32
< #include "ros/serialization.h"
< #include <boost/bind.hpp>
< 
< #include "ros/defines.h"
52c45
< class ROS_EXPORT Publisher
---
> class Publisher
67,90c60
<   template<typename M>
<   void publish(const boost::shared_ptr<M>& message) const
<   {
<     using namespace serialization;
< 
<     if (!impl_)
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     if (!impl_->isValid())
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     SerializedMessage m;
<     m.type_info = &typeid(M);
<     m.message = message;
< 
<     publish(boost::bind(serializeMessage<M>, boost::ref(*message)), m);
<   }
< 
---
>   void publish(const Message::ConstPtr& message) const;
94,113c64
<   template<typename M>
<   void publish(const M& message) const
<   {
<     using namespace serialization;
< 
<     if (!impl_)
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     if (!impl_->isValid())
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     SerializedMessage m;
<     publish(boost::bind(serializeMessage<M>, boost::ref(message)), m);
<   }
---
>   void publish(const Message& message) const;
137,141d87
<   /**
<    * \brief Returns whether or not this topic is latched
<    */
<   bool isLatched() const;
< 
162,165c108
<   void publish(const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m) const;
<   void incrementSequence() const;
< 
<   class ROS_EXPORT Impl
---
>   class Impl
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publisher_link.h tmp/old/core/roscpp/include/ros/publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
44,45d41
< #include "ros/defines.h"
< 
60c56
< class ROS_EXPORT PublisherLink : public boost::enable_shared_from_this<PublisherLink>
---
> class PublisherLink : public boost::enable_shared_from_this<PublisherLink>
86c82
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy) = 0;
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes) = 0;
90,91d85
<   const std::string& getMD5Sum();
< 
104d97
<   std::string md5sum_;
Only in tmp/msvc/core/roscpp/include/ros: roscpp_macros.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/rosout_appender.h tmp/old/core/roscpp/include/ros/rosout_appender.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45d42
< 
48,49d44
< #include "ros/defines.h"
< 
57c52
< class ROS_EXPORT ROSOutAppender : public log4cxx::AppenderSkeleton
---
> class ROSOutAppender : public log4cxx::AppenderSkeleton
76d70
< 
84,86c78
< #ifdef WIN32
< typedef log4cxx::helpers::ObjectPtrT<ROSOutAppender> ROSOutAppenderPtr;
< #else
---
> 
88d79
< #endif //WIN32
Only in tmp/msvc/core/roscpp/include/ros: service_callback_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client.h tmp/old/core/roscpp/include/ros/service_client.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,38c32
< #include "ros/common.h"
< #include "ros/service_traits.h"
< #include "ros/serialization.h"
< 
< #include "ros/defines.h"
---
> #include "ros/message.h"
46c40
< class ROS_EXPORT ServiceClient
---
> class ServiceClient
61,62d54
<     namespace st = service_traits;
< 
68c60
<     if (strcmp(st::md5sum(req), st::md5sum(res)))
---
>     if (req.__getServerMD5Sum() != res.__getServerMD5Sum())
70,75c62,67
<       ROS_ERROR("The request and response parameters to the service "
<                  "call must be autogenerated from the same "
<                  "server definition file (.srv). your service call "
<                  "for %s appeared to use request/response types "
<                  "from different .srv files. (%s vs. %s)", impl_->name_.c_str(), st::md5sum(req), st::md5sum(res));
<       return false;
---
>       ROS_FATAL("woah! the request and response parameters to the server "
>                    "callback function must be autogenerated from the same "
>                    "server definition file (.srv). your service call "
>                    "for %s appeared to use request/response types "
>                    "from different .srv files.", impl_->name_.c_str());
>       ROS_BREAK();
78c70
<     return call(req, res, st::md5sum(req));
---
>     return call(req, res, req.__getServerMD5Sum());
87,88d78
<     namespace st = service_traits;
< 
94c84
<     return call(service.request, service.response, st::md5sum(service));
---
>     return call(service.request, service.response, service.getMD5Sum());
98c88
<    * \brief Mostly for internal use, the other templated versions of call() just call into this one
---
>    * \brief Mostly for internal use, the templated versions of call() just call into this one
100,125c90
<   template<typename MReq, typename MRes>
<   bool call(const MReq& req, MRes& resp, const std::string& service_md5sum)
<   {
<     namespace ser = serialization;
<     SerializedMessage ser_req = ser::serializeMessage(req);
<     SerializedMessage ser_resp;
<     bool ok = call(ser_req, ser_resp, service_md5sum);
<     if (!ok)
<     {
<       return false;
<     }
< 
<     try
<     {
<       ser::deserializeMessage(ser_resp, resp);
<     }
<     catch (std::exception& e)
<     {
<       deserializeFailed(e);
<       return false;
<     }
< 
<     return true;
<   }
< 
<   bool call(const SerializedMessage& req, SerializedMessage& resp, const std::string& service_md5sum);
---
>   bool call(Message& req, Message& resp, const std::string& service_md5sum);
179,186d143
<   // This works around a problem with the OSX linker that causes the static variable declared by
<   // ROS_ERROR to error with missing symbols when it's used directly in the templated call() method above
<   // This for some reason only showed up in the rxtools package
<   void deserializeFailed(const std::exception& e)
<   {
<     ROS_ERROR("Exception thrown while while deserializing service call: %s", e.what());
<   }
< 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client_link.h tmp/old/core/roscpp/include/ros/service_client_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
38d35
< #include <boost/signals/connection.hpp>
42,43d38
< #include "ros/defines.h"
< 
46a42,43
> class Message;
> typedef boost::shared_ptr<Message> MessagePtr;
56c53
< class ROS_EXPORT ServiceClientLink : public boost::enable_shared_from_this<ServiceClientLink>
---
> class ServiceClientLink : public boost::enable_shared_from_this<ServiceClientLink>
71c68
<   void processResponse(bool ok, const SerializedMessage& res);
---
>   void processResponse(bool ok, const MessagePtr& resp);
85,86d81
<   bool persistent_;
<   boost::signals::connection dropped_conn_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client_options.h tmp/old/core/roscpp/include/ros/service_client_options.h
32d31
< #include "ros/service_traits.h"
72,73d70
<     namespace st = service_traits;
< 
75c72
<     md5sum = st::md5sum<MReq>();
---
>     md5sum = MReq::__s_getServerMD5Sum();
90,91d86
<     namespace st = service_traits;
< 
93c88
<     md5sum = st::md5sum<Service>();
---
>     md5sum = Service::getMD5Sum();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service.h tmp/old/core/roscpp/include/ros/service.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
38,39d35
< #include "ros/service_traits.h"
< #include "ros/names.h"
43,44d38
< #include "ros/defines.h"
< 
71d64
<   namespace st = service_traits;
73c66
<   ServiceClientOptions ops(ros::names::resolve(service_name), st::md5sum(req), false, M_string());
---
>   ServiceClientOptions ops(service_name, req.__getServerMD5Sum(), false, M_string());
91,92d83
<   namespace st = service_traits;
< 
94c85
<   ServiceClientOptions ops(ros::names::resolve(service_name), st::md5sum(service), false, M_string());
---
>   ServiceClientOptions ops(service_name, service.getMD5Sum(), false, M_string());
106c97
< ROS_EXPORT bool waitForService(const std::string& service_name, int32_t timeout);
---
> bool waitForService(const std::string& service_name, int32_t timeout);
115c106
< ROS_EXPORT bool waitForService(const std::string& service_name, ros::Duration timeout = ros::Duration(-1));
---
> bool waitForService(const std::string& service_name, ros::Duration timeout = ros::Duration(-1));
124c115
< ROS_EXPORT bool exists(const std::string& service_name, bool print_failure_reason);
---
> bool exists(const std::string& service_name, bool print_failure_reason);
140c131
<   ServiceClient client = nh.template serviceClient<MReq, MRes>(ros::names::resolve(service_name), persistent, header_values);
---
>   ServiceClient client = nh.template serviceClient<MReq, MRes>(service_name, persistent, header_values);
158c149
<   ServiceClient client = nh.template serviceClient<Service>(ros::names::resolve(service_name), persistent, header_values);
---
>   ServiceClient client = nh.template serviceClient<Service>(service_name, persistent, header_values);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_manager.h tmp/old/core/roscpp/include/ros/service_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
39,41d36
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
58c53
< class ROS_EXPORT ServiceManager
---
> class ServiceManager
140c135
<   boost::recursive_mutex shutting_down_mutex_;
---
>   boost::mutex shutting_down_mutex_;
Only in tmp/old/core/roscpp/include/ros: service_message_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_publication.h tmp/old/core/roscpp/include/ros/service_publication.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "ros/service_callback_helper.h"
---
> #include "ros/service_message_helper.h"
47,48d44
< #include "ros/defines.h"
< 
65c61
< class ROS_EXPORT ServicePublication : public boost::enable_shared_from_this<ServicePublication>
---
> class ServicePublication : public boost::enable_shared_from_this<ServicePublication>
69,70c65,66
<                 const std::string& response_data_type, const ServiceCallbackHelperPtr& helper, CallbackQueueInterface* queue,
<                 const VoidConstPtr& tracked_object);
---
>                 const std::string& response_data_type, const ServiceMessageHelperPtr& helper, CallbackQueueInterface* queue,
>                 const VoidPtr& tracked_object);
110c106
<   ServiceCallbackHelperPtr helper_;
---
>   ServiceMessageHelperPtr helper_;
119c115
<   VoidConstWPtr tracked_object_;
---
>   VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_server.h tmp/old/core/roscpp/include/ros/service_server.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
48c44
< class ROS_EXPORT ServiceServer
---
> class ServiceServer
88c84
<   class ROS_EXPORT Impl
---
>   class Impl
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_server_link.h tmp/old/core/roscpp/include/ros/service_server_link.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
49,50d46
< #include "ros/defines.h"
< 
62c58
< class ROS_EXPORT ServiceServerLink : public boost::enable_shared_from_this<ServiceServerLink>
---
> class ServiceServerLink : public boost::enable_shared_from_this<ServiceServerLink>
67,68c63,64
<     SerializedMessage req_;
<     SerializedMessage* resp_;
---
>     Message* req_;
>     Message* resp_;
110c106
<   bool call(const SerializedMessage& req, SerializedMessage& resp);
---
>   bool call(Message* req, Message* resp);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/single_subscriber_publisher.h tmp/old/core/roscpp/include/ros/single_subscriber_publisher.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35d32
< #include "ros/serialization.h"
39,40d35
< #include "ros/defines.h"
< 
47c42
< class ROS_EXPORT SingleSubscriberPublisher : public boost::noncopyable
---
> class SingleSubscriberPublisher : public boost::noncopyable
61,80c56
<   template<class M>
<   void publish(const boost::shared_ptr<M const>& message) const
<   {
<     publish(*message);
<   }
< 
<   /**
<    * \brief Publish a message on the topic associated with this Publisher.
<    *
<    * This version of publish will allow fast intra-process message-passing in the future,
<    * so you may not mutate the message after it has been passed in here (since it will be
<    * passed directly into a callback function)
<    *
<    */
<   template<class M>
<   void publish(const boost::shared_ptr<M>& message) const
<   {
<     publish(*message);
<   }
< 
---
>   void publish(const Message::ConstPtr& message) const;
84,90c60
<   template<class M>
<   void publish(const M& message) const
<   {
<     using namespace serialization;
<     SerializedMessage m = serializeMessage(message);
<     publish(m);
<   }
---
>   void publish(const Message& message) const;
103d72
<   void publish(const SerializedMessage& m) const;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/spinner.h tmp/old/core/roscpp/include/ros/spinner.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
37,38d34
< #include "ros/defines.h"
< 
61c57
< class ROS_EXPORT SingleThreadedSpinner : public Spinner
---
> class SingleThreadedSpinner : public Spinner
70c66
< class ROS_EXPORT MultiThreadedSpinner : public Spinner
---
> class MultiThreadedSpinner : public Spinner
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscribe_options.h tmp/old/core/roscpp/include/ros/subscribe_options.h
33,34c33
< #include "ros/message_traits.h"
< #include "subscription_callback_helper.h"
---
> #include "subscription_message_helper.h"
50d48
<   , allow_concurrent_callbacks(false)
60,61c58
<    * \param _md5sum
<    * \param _datatype
---
>    * \param _helper Helper object used to get create messages and call callbacks
63c60
<   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const std::string& _md5sum, const std::string& _datatype)
---
>   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const SubscriptionMessageHelperPtr& _helper)
66,67c63,65
<   , md5sum(_md5sum)
<   , datatype(_datatype)
---
>   , md5sum(_helper->getMD5Sum())
>   , datatype(_helper->getDataType())
>   , helper(_helper)
69d66
<   , allow_concurrent_callbacks(false)
73c70
<    * \brief Templated initialization, templated on callback parameter type.  Supports any callback parameters supported by the SubscriptionCallbackAdapter
---
>    * \brief Constructor
78c75,76
<    * \param _callback Callback to call when a message arrives on this topic
---
>    * \param _md5sum
>    * \param _datatype
80,91c78,84
<   template<class P>
<   void initByFullCallbackType(const std::string& _topic, uint32_t _queue_size,
<        const boost::function<void (P)>& _callback,
<        const boost::function<boost::shared_ptr<typename ParameterAdapter<P>::Message>(void)>& factory_fn = defaultMessageCreateFunction<typename ParameterAdapter<P>::Message>)
<   {
<     typedef typename ParameterAdapter<P>::Message MessageType;
<     topic = _topic;
<     queue_size = _queue_size;
<     md5sum = message_traits::md5sum<MessageType>();
<     datatype = message_traits::datatype<MessageType>();
<     helper = SubscriptionCallbackHelperPtr(new SubscriptionCallbackHelperT<P>(_callback, factory_fn));
<   }
---
>   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const std::string& _md5sum, const std::string& _datatype)
>   : topic(_topic)
>   , queue_size(_queue_size)
>   , md5sum(_md5sum)
>   , datatype(_datatype)
>   , callback_queue(0)
>   {}
94c87
<    * \brief Templated initialization, templated on message type.  Only supports "const boost::shared_ptr<M const>&" callback types
---
>    * \brief Templated initialization
103,104c96
<        const boost::function<void (const boost::shared_ptr<M const>&)>& _callback,
<        const boost::function<boost::shared_ptr<M>(void)>& factory_fn = defaultMessageCreateFunction<M>)
---
>        const boost::function<void (const boost::shared_ptr<M>&)>& _callback)
106d97
<     typedef typename ParameterAdapter<M>::Message MessageType;
109,111c100,102
<     md5sum = message_traits::md5sum<MessageType>();
<     datatype = message_traits::datatype<MessageType>();
<     helper = SubscriptionCallbackHelperPtr(new SubscriptionCallbackHelperT<const boost::shared_ptr<MessageType const>&>(_callback, factory_fn));
---
>     md5sum = M::__s_getMD5Sum();
>     datatype = M::__s_getDataType();
>     helper = SubscriptionMessageHelperPtr(new SubscriptionMessageHelperT<M>(_callback));
120c111
<   SubscriptionCallbackHelperPtr helper;                              ///< Helper object used to get create messages and call callbacks
---
>   SubscriptionMessageHelperPtr helper;                              ///< Helper object used to get create messages and call callbacks
124,127d114
<   /// By default subscription callbacks are guaranteed to arrive in-order, with only one callback happening for this subscription at any given
<   /// time.  Setting this to true allows you to receive multiple messages on the same topic from multiple threads at the same time
<   bool allow_concurrent_callbacks;
< 
138c125
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
154,155c141,142
<                                  const boost::function<void (const boost::shared_ptr<M const>&)>& callback,
<                                  const VoidConstPtr& tracked_object, CallbackQueueInterface* queue)
---
>                                  const boost::function<void (const boost::shared_ptr<M>&)>& callback,
>                                  const VoidPtr& tracked_object, CallbackQueueInterface* queue)
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscriber.h tmp/old/core/roscpp/include/ros/subscriber.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,36c32
< #include "ros/subscription_callback_helper.h"
< 
< #include "ros/defines.h"
---
> #include "ros/subscription_message_helper.h"
49c45
< class ROS_EXPORT Subscriber
---
> class Subscriber
92c88
<   Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionCallbackHelperPtr& helper);
---
>   Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionMessageHelperPtr& helper);
94c90
<   class ROS_EXPORT Impl
---
>   class Impl
105c101
<     SubscriptionCallbackHelperPtr helper_;
---
>     SubscriptionMessageHelperPtr helper_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscriber_link.h tmp/old/core/roscpp/include/ros/subscriber_link.h
69a70,74
>    * \brief Publish a message directly to our subscriber.  Useful for publication connection callbacks
>    * to publish directly to the new subscriber and no-one else
>    */
>   virtual bool publish(const Message& m) = 0;
>   /**
72c77
<   virtual void enqueueMessage(const SerializedMessage& m, bool nocopy, bool ser) = 0;
---
>   virtual void enqueueMessage(const SerializedMessage& m) = 0;
78,84d82
<   virtual bool isIntraprocess() { return false; }
<   virtual void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti) { ser = true; nocopy = false; }
< 
<   const std::string& getMD5Sum();
<   const std::string& getDataType();
<   const std::string& getMessageDefinition();
< 
Only in tmp/msvc/core/roscpp/include/ros: subscription_callback_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscription.h tmp/old/core/roscpp/include/ros/subscription.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35a34
> #include "ros/subscription_message_helper.h"
45,46d43
< #include "ros/defines.h"
< 
62,63d58
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
68c63
< class ROS_EXPORT Subscription : public boost::enable_shared_from_this<Subscription>
---
> class Subscription : public boost::enable_shared_from_this<Subscription>
102,103c97,98
<   bool addCallback(const SubscriptionCallbackHelperPtr& helper, const std::string& md5sum, CallbackQueueInterface* queue, int32_t queue_size, const VoidConstPtr& tracked_object, bool allow_concurrent_callbacks);
<   void removeCallback(const SubscriptionCallbackHelperPtr& helper);
---
>   bool addCallback(const SubscriptionMessageHelperPtr& helper, CallbackQueueInterface* queue, int32_t queue_size, const VoidPtr& tracked_object);
>   void removeCallback(const SubscriptionMessageHelperPtr& helper);
111c106
<   uint32_t handleMessage(const SerializedMessage& m, bool ser, bool nocopy, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link);
---
>   uint32_t handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link);
185,188d179
<   void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
< 
<   void headerReceived(const PublisherLinkPtr& link, const Header& h);
< 
195,196d185
<   void addPublisherLink(const PublisherLinkPtr& link);
< 
202c191
<     SubscriptionCallbackHelperPtr helper_;
---
>     SubscriptionMessageHelperPtr helper_;
205c194
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
211d199
<   boost::mutex md5sum_mutex_;
216d203
<   uint32_t nonconst_callbacks_;
232,244c219,220
<   struct LatchInfo
<   {
<     SerializedMessage message;
<     PublisherLinkPtr link;
<     boost::shared_ptr<std::map<std::string, std::string> > connection_header;
<     ros::Time receipt_time;
<   };
< 
<   typedef std::map<PublisherLinkPtr, LatchInfo> M_PublisherLinkToLatchInfo;
<   M_PublisherLinkToLatchInfo latched_messages_;
< 
<   typedef std::vector<std::pair<const std::type_info*, MessageDeserializerPtr> > V_TypeAndDeserializer;
<   V_TypeAndDeserializer cached_deserializers_;
---
>   typedef std::map<PublisherLinkPtr, MessageDeserializerPtr> M_PublisherLinkToDeserializer;
>   M_PublisherLinkToDeserializer latched_messages_;
Only in tmp/old/core/roscpp/include/ros: subscription_message_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscription_queue.h tmp/old/core/roscpp/include/ros/subscription_queue.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35c33
< #include "message_event.h"
---
> #include "subscription_message_helper.h"
41,43c39
< #include <deque>
< 
< #include "ros/defines.h"
---
> #include <list>
51,54c47
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT SubscriptionQueue : public CallbackInterface, public boost::enable_shared_from_this<SubscriptionQueue>
---
> class SubscriptionQueue : public boost::enable_shared_from_this<SubscriptionQueue>
59c52
<     SubscriptionCallbackHelperPtr helper;
---
>     SubscriptionMessageHelperPtr helper;
63c56
<     VoidConstWPtr tracked_object;
---
>     VoidWPtr tracked_object;
65,66c58
<     bool nonconst_need_copy;
<     ros::Time receipt_time;
---
>     uint64_t id;
68c60
<   typedef std::deque<Item> D_Item;
---
>   typedef std::list<Item> L_Item;
71c63
<   SubscriptionQueue(const std::string& topic, int32_t queue_size, bool allow_concurrent_callbacks);
---
>   SubscriptionQueue(const std::string& topic, int32_t queue_size);
73c65
<   void push(const SubscriptionCallbackHelperPtr& helper, const MessageDeserializerPtr& deserializer, bool has_tracked_object, const VoidConstWPtr& tracked_object, bool nonconst_need_copy, ros::Time receipt_time = ros::Time(), bool* was_full = 0);
---
>   uint64_t push(const SubscriptionMessageHelperPtr& helper, const MessageDeserializerPtr& deserializer, bool has_tracked_object, const VoidWPtr& tracked_object);
75,77c67,68
< 
<   virtual CallbackInterface::CallResult call();
<   virtual bool ready();
---
>   CallbackInterface::CallResult call(uint64_t id);
>   bool ready(uint64_t id);
78a70
>   void remove(uint64_t id);
84a77
>   uint64_t id_counter_;
87c80
<   D_Item queue_;
---
>   L_Item queue_;
89d81
<   bool allow_concurrent_callbacks_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/this_node.h tmp/old/core/roscpp/include/ros/this_node.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
49c45
< const ROS_EXPORT std::string& getName();
---
> const std::string& getName();
53c49
< const ROS_EXPORT std::string& getNamespace();
---
> const std::string& getNamespace();
59c55
< ROS_EXPORT void getAdvertisedTopics(V_string& topics);
---
> void getAdvertisedTopics(V_string& topics);
65c61
< ROS_EXPORT void getSubscribedTopics(V_string& topics);
---
> void getSubscribedTopics(V_string& topics);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer.h tmp/old/core/roscpp/include/ros/timer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
49c45
< class ROS_EXPORT Timer
---
> class Timer
71,75d66
<   /**
<    * \brief Set the period of this timer
<    */
<   void setPeriod(const Duration& period);
< 
97c88
<   class ROS_EXPORT Impl
---
>   class Impl
105d95
<     void setPeriod(const Duration& period);
116c106
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer_manager.h tmp/old/core/roscpp/include/ros/timer_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45,47d42
< #include <vector>
< #include <list>
< 
60a56
>     boost::recursive_mutex callback_mutex;
72c68
<     VoidConstWPtr tracked_object;
---
>     VoidWPtr tracked_object;
75,76d70
<     // TODO: atomicize
<     boost::mutex waiting_mutex;
88,89d81
<   typedef std::list<int32_t> L_int32;
< 
94c86
<   int32_t add(const D& period, const boost::function<void(const E&)>& callback, CallbackQueueInterface* callback_queue, const VoidConstPtr& tracked_object, bool oneshot);
---
>   int32_t add(const D& period, const boost::function<void(const E&)>& callback, CallbackQueueInterface* callback_queue, const VoidPtr& tracked_object, bool oneshot);
98d89
<   void setPeriod(int32_t handle, const D& period);
109c100
<   bool waitingCompare(int32_t lhs, int32_t rhs);
---
>   bool timerCompare(const TimerInfoPtr& lhs, const TimerInfoPtr& rhs);
111,159d101
< #ifdef WIN32
<     void schedule(const TimerInfoPtr& info)
<   {
< 	  {
< 		boost::mutex::scoped_lock lock(waiting_mutex_);
< 
< 		if (info->removed)
< 		{
< 		  return;
< 		}
< 
< 		updateNext(info, T::now());
< 		waiting_.push_back(info->handle);
< 		waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
< 	  }
< 
< 	  new_timer_ = true;
< 	  timers_cond_.notify_one();
<   }
<   void updateNext(const TimerInfoPtr& info, const T& current_time)
<   {
< 	  if (info->oneshot)
< 	  {
< 		info->next_expected = T(INT_MAX, 999999999);
< 	  }
< 	  else
< 	  {
< 		// Protect against someone having called setPeriod()
< 		// If the next expected time is already past the current time
< 		// don't update it
< 		if (info->next_expected <= current_time)
< 		{
< 		  info->last_expected = info->next_expected;
< 		  info->next_expected += info->period;
< 		}
< 
< 		// detect time jumping forward, as well as callbacks that are too slow
< 		if (info->next_expected + info->period < current_time)
< 		{
< 		  //ROS_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
< 		  printf("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
< 		  info->next_expected = current_time;
< 		}
< 	  }
<   }
< #else
<   void schedule(const TimerInfoPtr& info);
<   void updateNext(const TimerInfoPtr& info, const T& current_time);
< #endif //WIN32
166,168d107
<   boost::mutex waiting_mutex_;
<   L_int32 waiting_;
< 
181,187c120,121
<     TimerQueueCallback(TimerManager<T, D, E>* parent, const TimerInfoPtr& info, T last_expected, T last_real, T current_expected)
<     : parent_(parent)
<     , info_(info)
<     , last_expected_(last_expected)
<     , last_real_(last_real)
<     , current_expected_(current_expected)
<     , called_(false)
---
>     TimerQueueCallback(const TimerInfoPtr& info, T last_expected, T last_real, T current_expected) :
>       info_(info), last_expected_(last_expected), last_real_(last_real), current_expected_(current_expected), called_(false)
189c123
<       boost::mutex::scoped_lock lock(info->waiting_mutex);
---
>       boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
198c132
<         boost::mutex::scoped_lock lock(info->waiting_mutex);
---
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
211a146,147
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
> 
215c151,156
<         VoidConstPtr tracked;
---
>         if (info->removed)
>         {
>           return Invalid;
>         }
> 
>         VoidPtr tracked;
238,239d178
< 
<         parent_->schedule(info);
246d184
<     TimerManager<T, D, E>* parent_;
274c212
< bool TimerManager<T, D, E>::waitingCompare(int32_t lhs, int32_t rhs)
---
> bool TimerManager<T, D, E>::timerCompare(const TimerInfoPtr& lhs, const TimerInfoPtr& rhs)
276,283c214
<   TimerInfoPtr infol = findTimer(lhs);
<   TimerInfoPtr infor = findTimer(rhs);
<   if (!infol || !infor)
<   {
<     return infol < infor;
<   }
< 
<   return infol->next_expected < infor->next_expected;
---
>   return lhs->next_expected < rhs->next_expected;
315c246
<     VoidConstPtr tracked = info->tracked_object.lock();
---
>     VoidPtr tracked = info->tracked_object.lock();
322d252
<   boost::mutex::scoped_lock lock2(info->waiting_mutex);
328c258
<                                    const VoidConstPtr& tracked_object, bool oneshot)
---
>                                    const VoidPtr& tracked_object, bool oneshot)
352,361c282,284
<   {
<     boost::mutex::scoped_lock lock(timers_mutex_);
<     timers_.push_back(info);
< 
<     if (!thread_started_)
<     {
<       thread_ = boost::thread(boost::bind(&TimerManager::threadFunc, this));
<       thread_started_ = true;
<     }
<   }
---
>   boost::mutex::scoped_lock lock(timers_mutex_);
>   timers_.push_back(info);
>   std::sort(timers_.begin(), timers_.end(), boost::bind(&TimerManager::timerCompare, this, _1, _2));
362a286
>   if (!thread_started_)
364,366c288,289
<     boost::mutex::scoped_lock lock(waiting_mutex_);
<     waiting_.push_back(info->handle);
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
---
>     thread_ = boost::thread(boost::bind(&TimerManager::threadFunc, this));
>     thread_started_ = true;
387,388c310,314
<       info->removed = true;
<       info->callback_queue->removeByID((uint64_t)info.get());
---
>       {
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
>         info->removed = true;
>         info->callback_queue->removeByID((uint64_t)info.get());
>       }
393,474d318
< 
<   {
<     boost::mutex::scoped_lock lock2(waiting_mutex_);
<     // Remove from the waiting list if it's in it
<     L_int32::iterator it = std::find(waiting_.begin(), waiting_.end(), handle);
<     if (it != waiting_.end())
<     {
<       waiting_.erase(it);
<     }
<   }
< }
< 
< #ifndef WIN32
< template<class T, class D, class E>
< void TimerManager<T, D, E>::schedule(const TimerManager<T, D, E>::TimerInfoPtr& info)
< {
<   {
<     boost::mutex::scoped_lock lock(waiting_mutex_);
< 
<     if (info->removed)
<     {
<       return;
<     }
< 
<     updateNext(info, T::now());
<     waiting_.push_back(info->handle);
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
<   }
< 
<   new_timer_ = true;
<   timers_cond_.notify_one();
< }
< 
< template<class T, class D, class E>
< void TimerManager<T, D, E>::updateNext(const TimerManager<T, D, E>::TimerInfoPtr& info, const T& current_time)
< {
<   if (info->oneshot)
<   {
<     info->next_expected = T(INT_MAX, 999999999);
<   }
<   else
<   {
<     // Protect against someone having called setPeriod()
<     // If the next expected time is already past the current time
<     // don't update it
<     if (info->next_expected <= current_time)
<     {
<       info->last_expected = info->next_expected;
<       info->next_expected += info->period;
<     }
< 
<     // detect time jumping forward, as well as callbacks that are too slow
<     if (info->next_expected + info->period < current_time)
<     {
<       ROS_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
<       info->next_expected = current_time;
<     }
<   }
< }
< #endif //WIN32
< 
< template<class T, class D, class E>
< void TimerManager<T, D, E>::setPeriod(int32_t handle, const D& period)
< {
<   boost::mutex::scoped_lock lock(timers_mutex_);
<   TimerInfoPtr info = findTimer(handle);
< 
<   if (!info)
<   {
<     return;
<   }
< 
<   {
<     boost::mutex::scoped_lock lock(waiting_mutex_);
<     info->period = period;
<     info->next_expected = T::now() + period;
< 
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
<   }
< 
<   new_timer_ = true;
<   timers_cond_.notify_one();
510a355,359
>     if (timers_.empty())
>     {
>       sleep_end = current + D(0.1);
>     }
>     else
512c361
<       boost::mutex::scoped_lock waitlock(waiting_mutex_);
---
>       TimerInfoPtr info = timers_.front();
514,518c363
<       if (waiting_.empty())
<       {
<         sleep_end = current + D(0.1);
<       }
<       else
---
>       while (info->next_expected <= current)
520,524c365
<         TimerInfoPtr info = findTimer(waiting_.front());
< 
<         while (!waiting_.empty() && info && info->next_expected <= current)
<         {
<           current = T::now();
---
>         current = T::now();
526,528c367,369
<           //ROS_DEBUG("Scheduling timer callback for timer [%d] of period [%f], [%f] off expected", info->handle, info->period.toSec(), (current - info->next_expected).toSec());
<           CallbackInterfacePtr cb(new TimerQueueCallback(this, info, info->last_expected, info->last_real, info->next_expected));
<           info->callback_queue->addCallback(cb, (uint64_t)info.get());
---
>         ROS_DEBUG("Scheduling timer callback for timer of period [%f]", info->period.toSec());
>         CallbackInterfacePtr cb(new TimerQueueCallback(info, info->last_expected, info->last_real, info->next_expected));
>         info->callback_queue->addCallback(cb, (uint64_t)info.get());
530c371,378
<           waiting_.pop_front();
---
>         if (info->oneshot)
>         {
>           info->next_expected = T(INT_MAX, 999999999);
>         }
>         else
>         {
>           info->last_expected = info->next_expected;
>           info->next_expected += info->period;
532c380,381
<           if (waiting_.empty())
---
>           // detect time jumping forward, as well as callbacks that are too slow
>           if (info->next_expected + info->period < current)
534c383,384
<             break;
---
>             ROSCPP_LOG_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current - info->next_expected).toSec(), info->period.toSec(), current.toSec(), info->next_expected.toSec());
>             info->next_expected = current;
536,537d385
< 
<           info = findTimer(waiting_.front());
540,543c388,398
<         if (info)
<         {
<           sleep_end = info->next_expected;
<         }
---
>         std::sort(timers_.begin(), timers_.end(), boost::bind(&TimerManager::timerCompare, this, _1, _2));
>         info = timers_.front();
>       }
> 
>       if (info)
>       {
>         sleep_end = info->next_expected;
>       }
>       else
>       {
> 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer_options.h tmp/old/core/roscpp/include/ros/timer_options.h
72c72
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/topic.h tmp/old/core/roscpp/include/ros/topic.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43,44d40
< #include "ros/defines.h"
< 
53c49
< ROS_EXPORT void waitForMessageImpl(SubscribeOptions& ops, const boost::function<bool(void)>& ready_pred, NodeHandle& nh, ros::Duration timeout);
---
> void waitForMessageImpl(SubscribeOptions& ops, const boost::function<bool(void)>& ready_pred, NodeHandle& nh, ros::Duration timeout);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/topic_manager.h tmp/old/core/roscpp/include/ros/topic_manager.h
33c33,34
< #include "ros/serialization.h"
---
> #include "subscribe_options.h"
> #include "advertise_options.h"
41,42d41
< #include "ros/defines.h"
< 
47,48d45
< class SubscribeOptions;
< class AdvertiseOptions;
62,65c59
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT TopicManager
---
> class TopicManager
77c71
<   bool unsubscribe(const std::string &_topic, const SubscriptionCallbackHelperPtr& helper);
---
>   bool unsubscribe(const std::string &_topic, const SubscriptionMessageHelperPtr& helper);
123,132c117,134
<   template<typename M>
<   void publish(const std::string& topic, const M& message)
<   {
<     using namespace serialization;
< 
<     SerializedMessage m;
<     publish(topic, boost::bind(serializeMessage<M>, boost::ref(message)), m);
<   }
< 
<   void publish(const std::string &_topic, const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m);
---
>   /** @brief Publish a message.
>    *
>    * This method publishes a message on a topic, delivering it to any
>    * currently connected subscribers.  If no subscribers are connected,
>    * this call does nothing.
>    *
>    * You must have already called \ref advertise()
>    * on the topic you are trying to publish to, and the type supplied in
>    * the advertise() call must match the type of the message you are trying
>    * to publish.
>    *
>    * This method can be safely called from within a subscriber connection
>    * callback.
>    *
>    * @param _topic The topic to publish to.
>    * @param msg Message to be published.
>    */
>   void publish(const std::string &_topic, const Message& m);
134,135c136
<   void incrementSequence(const std::string &_topic);
<   bool isLatched(const std::string& topic);
---
>   void publish(const PublicationPtr& p, const Message& m);
168c169
<   void processPublishQueues();
---
>   void processPublishQueue();
212a214,217
>   typedef std::vector<std::pair<PublicationPtr, SerializedMessage> > V_PublicationAndSerializedMessagePair;
>   V_PublicationAndSerializedMessagePair publish_queue_;
>   boost::mutex publish_queue_mutex_;
> 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport.h tmp/old/core/roscpp/include/ros/transport/transport.h
85,93d84
<    * \brief Enable reading on this transport.  Allows derived classes to, for example, enable read polling for asynchronous sockets
<    */
<   virtual void enableRead() = 0;
<   /**
<    * \brief Disable reading on this transport.  Allows derived classes to, for example, disable read polling for asynchronous sockets
<    */
<   virtual void disableRead() = 0;
< 
<   /**
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport_tcp.h tmp/old/core/roscpp/include/ros/transport/transport_tcp.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45d42
< #ifndef WIN32
47d43
< #endif //WIN32
107,109d102
<   const std::string& getConnectedHost() { return connected_host_; }
<   int getConnectedPort() { return connected_port_; }
< 
116,117d108
<   virtual void enableRead();
<   virtual void disableRead();
133,134d123
<   bool setNonBlocking();
< 
141a131,135
>   /**
>    * \brief Enables reading on our socket
>    */
>   void enableRead();
> 
160,162d153
< 
<   std::string connected_host_;
<   int connected_port_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport_udp.h tmp/old/core/roscpp/include/ros/transport/transport_udp.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43a42
> #include <boost/random.hpp>
45d43
< #ifndef WIN32
47d44
< #endif //WIN32
108a106,110
>   /**
>    * \brief Get a unique connection ID
>    */
>   int generateConnectionId() {return gen_();}
> 
115,116d116
<   virtual void enableRead();
<   virtual void disableRead();
140a141,145
>   /**
>    * \brief Enables reading on our socket
>    */
>   void enableRead();
> 
158a164,165
>   boost::rand48 gen_;
> 
166,171c173
<   uint8_t* data_buffer_;
<   uint8_t* data_start_;
<   uint32_t data_filled_;
< 
<   uint8_t* reorder_buffer_;
<   uint8_t* reorder_start_;
---
>   uint8_t *reorder_buffer_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport_publisher_link.h tmp/old/core/roscpp/include/ros/transport_publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33,36d30
< #ifdef WIN32
< #include <winsock2.h>
< #endif //WIN32
< 
38,40d31
< #include "connection.h"
< 
< #include "ros/defines.h"
52,53d42
< class WallTimerEvent;
< 
58c47
< class ROS_EXPORT TransportPublisherLink : public PublisherLink
---
> class TransportPublisherLink : public PublisherLink
73c62
<   void onConnectionDropped(const ConnectionPtr& conn, Connection::DropReason reason);
---
>   void onConnectionDropped(const ConnectionPtr& conn);
79c68
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes);
85,86d73
<   void onRetryTimer(const ros::WallTimerEvent&);
< 
88,93d74
< 
<   int32_t retry_timer_handle_;
<   bool needs_retry_;
<   WallDuration retry_period_;
<   WallTime next_retry_;
<   bool dropping_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport_subscriber_link.h tmp/old/core/roscpp/include/ros/transport_subscriber_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,37d31
< #include <boost/signals/connection.hpp>
< 
< #include "ros/defines.h"
< 
44c38
< class ROS_EXPORT TransportSubscriberLink : public SubscriberLink
---
> class TransportSubscriberLink : public SubscriberLink
56c50,51
<   virtual void enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual bool publish(const Message& m);
>   virtual void enqueueMessage(const SerializedMessage& m);
71d65
<   boost::signals::connection dropped_conn_;
Only in tmp/old/core/roscpp/include/ros: types.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/wall_timer.h tmp/old/core/roscpp/include/ros/wall_timer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
49c45
< class ROS_EXPORT WallTimer
---
> class WallTimer
71,75d66
<   /**
<    * \brief Set the period of this timer
<    */
<   void setPeriod(const WallDuration& period);
< 
97c88
<   class ROS_EXPORT Impl
---
>   class Impl
105d95
<     void setPeriod(const WallDuration& period);
116c106
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/wall_timer_options.h tmp/old/core/roscpp/include/ros/wall_timer_options.h
72c72
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/xmlrpc_manager.h tmp/old/core/roscpp/include/ros/xmlrpc_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
44d41
< #include "ros/defines.h"
47a45
> 
53,55c51,53
< ROS_EXPORT XmlRpc::XmlRpcValue responseStr(int code, const std::string& msg, const std::string& response);
< ROS_EXPORT XmlRpc::XmlRpcValue responseInt(int code, const std::string& msg, int response);
< ROS_EXPORT XmlRpc::XmlRpcValue responseBool(int code, const std::string& msg, bool response);
---
> XmlRpc::XmlRpcValue responseStr(int code, const std::string& msg, const std::string& response);
> XmlRpc::XmlRpcValue responseInt(int code, const std::string& msg, int response);
> XmlRpc::XmlRpcValue responseBool(int code, const std::string& msg, bool response);
95c93
< class ROS_EXPORT XMLRPCManager
---
> class XMLRPCManager
diff -r -x .svn tmp/msvc/core/roscpp/manifest.xml tmp/old/core/roscpp/manifest.xml
26c26
<     <cpp cflags="-I${prefix}/include `rosboost-cfg --cflags`" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib -lros `rosboost-cfg --lflags thread,signals`"/>
---
>     <cpp cflags="-I${prefix}/include `rosboost-cfg --cflags` -I${prefix}/srv/cpp -I${prefix}/msg/cpp" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib -lros `rosboost-cfg --lflags thread,signals`"/>
30,33d29
<   <platform os="ubuntu" version="9.04"/>
<   <platform os="ubuntu" version="9.10"/>
<   <platform os="ubuntu" version="10.04"/>
<   <platform os="macports" version="macports"/>
Only in tmp/msvc/core/roscpp/: msg_gen
Only in tmp/msvc/core/roscpp/scripts: genmsg_cpp.py
Only in tmp/msvc/core/roscpp/scripts: gensrv_cpp.py
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/callback_queue.cpp tmp/old/core/roscpp/src/libros/callback_queue.cpp
42,43c42
< : calling_(0)
< , enabled_(enabled)
---
> : enabled_(enabled)
79c78
<   return callbacks_.empty() && calling_ == 0;
---
>   return callbacks_.empty();
99,101c98
<   CallbackInfo info;
<   info.callback = callback;
<   info.removal_id = removal_id;
---
>   boost::mutex::scoped_lock lock(mutex_);
102a100
>   if (!enabled_)
104c102,103
<     boost::mutex::scoped_lock lock(mutex_);
---
>     return;
>   }
106,109c105
<     if (!enabled_)
<     {
<       return;
<     }
---
>   setupTLS();
111,112c107,110
<     callbacks_.push_back(info);
<   }
---
>   CallbackInfo info;
>   info.callback = callback;
>   info.removal_id = removal_id;
>   callbacks_.push_back(info);
113a112,113
>   M_IDInfo::iterator it = id_info_.find(removal_id);
>   if (it == id_info_.end())
115,123c115,117
<     boost::mutex::scoped_lock lock(id_info_mutex_);
< 
<     M_IDInfo::iterator it = id_info_.find(removal_id);
<     if (it == id_info_.end())
<     {
<       IDInfoPtr id_info(new IDInfo);
<       id_info->id = removal_id;
<       id_info_.insert(std::make_pair(removal_id, id_info));
<     }
---
>     IDInfoPtr id_info(new IDInfo);
>     id_info->id = removal_id;
>     id_info_.insert(std::make_pair(removal_id, id_info));
170,171c164,166
<       D_CallbackInfo::iterator it = callbacks_.begin();
<       for (; it != callbacks_.end();)
---
>       L_CallbackInfo::iterator it = callbacks_.begin();
>       L_CallbackInfo::iterator end = callbacks_.end();
>       for (; it != end;)
194,195c189,190
<     D_CallbackInfo::iterator it = tls_->callbacks.begin();
<     D_CallbackInfo::iterator end = tls_->callbacks.end();
---
>     L_CallbackInfo::iterator it = tls_->callbacks.begin();
>     L_CallbackInfo::iterator end = tls_->callbacks.end();
212c207
< CallbackQueue::CallOneResult CallbackQueue::callOne(ros::WallDuration timeout)
---
> void CallbackQueue::callOne(ros::WallDuration timeout)
215d209
<   TLS* tls = tls_.get();
224c218
<       return Disabled;
---
>       return;
234,239c228
<       if (callbacks_.empty())
<       {
<         return Empty;
<       }
< 
<       if (!enabled_)
---
>       if (callbacks_.empty() || !enabled_)
241c230
<         return Disabled;
---
>         return;
245,246c234,236
<     D_CallbackInfo::iterator it = callbacks_.begin();
<     for (; it != callbacks_.end();)
---
>     L_CallbackInfo::iterator it = callbacks_.begin();
>     L_CallbackInfo::iterator end = callbacks_.end();
>     for (; it != end;)
268c258
<       return TryAgain;
---
>       return;
270,271d259
< 
<     ++calling_;
274,276d261
<   bool was_empty = tls->callbacks.empty();
<   tls->callbacks.push_back(cb_info);
<   if (was_empty)
278,279c263,270
<     tls->cb_it = tls->callbacks.begin();
<   }
---
>     IDInfoPtr id_info = getIDInfo(cb_info.removal_id);
>     if (id_info)
>     {
>       boost::shared_lock<boost::shared_mutex> rw_lock(id_info->calling_rw_mutex);
>       if (!cb_info.marked_for_removal)
>       {
>         tls_->calling_in_this_thread = id_info->id;
>         tls_->callbacks.push_back(cb_info);
281,285c272,283
<   CallOneResult res = callOneCB(tls);
<   if (res != Empty)
<   {
<     boost::mutex::scoped_lock lock(mutex_);
<     --calling_;
---
>         CallbackInterface::CallResult result = cb_info.callback->call();
> 
>         tls_->calling_in_this_thread = 0xffffffffffffffffULL;
>         tls_->callbacks.clear();
> 
>         if (result == CallbackInterface::TryAgain && !cb_info.marked_for_removal)
>         {
>           boost::mutex::scoped_lock lock(mutex_);
>           callbacks_.push_front(cb_info);
>         }
>       }
>     }
287d284
<   return res;
293d289
<   TLS* tls = tls_.get();
316,326c312
<     bool was_empty = tls->callbacks.empty();
< 
<     tls->callbacks.insert(tls->callbacks.end(), callbacks_.begin(), callbacks_.end());
<     callbacks_.clear();
< 
<     calling_ += tls->callbacks.size();
< 
<     if (was_empty)
<     {
<       tls->cb_it = tls->callbacks.begin();
<     }
---
>     tls_->callbacks.swap(callbacks_);
329,331d314
<   size_t called = 0;
< 
<   while (!tls->callbacks.empty())
333c316,318
<     if (callOneCB(tls) != Empty)
---
>     L_CallbackInfo::iterator it = tls_->callbacks.begin();
>     L_CallbackInfo::iterator end = tls_->callbacks.end();
>     for (; it != end;)
335,360c320,321
<       ++called;
<     }
<   }
< 
<   {
<     boost::mutex::scoped_lock lock(mutex_);
<     calling_ -= called;
<   }
< }
< 
< CallbackQueue::CallOneResult CallbackQueue::callOneCB(TLS* tls)
< {
<   // Check for a recursive call.  If recursive, increment the current iterator.  Otherwise
<   // set the iterator it the beginning of the thread-local callbacks
<   if (tls->calling_in_this_thread == 0xffffffffffffffffULL)
<   {
<     tls->cb_it = tls->callbacks.begin();
<   }
< 
<   if (tls->cb_it == tls->callbacks.end())
<   {
<     return Empty;
<   }
< 
<   ROS_ASSERT(!tls->callbacks.empty());
<   ROS_ASSERT(tls->cb_it != tls->callbacks.end());
---
>       CallbackInfo& info = *it;
>       CallbackInterfacePtr& cb = info.callback;
362,363c323,327
<   CallbackInfo info = *tls->cb_it;
<   CallbackInterfacePtr& cb = info.callback;
---
>       IDInfoPtr id_info = getIDInfo(info.removal_id);
>       if (id_info)
>       {
>         boost::shared_lock<boost::shared_mutex> rw_lock(id_info->calling_rw_mutex);
>         tls_->calling_in_this_thread = id_info->id;
365,368c329,333
<   IDInfoPtr id_info = getIDInfo(info.removal_id);
<   if (id_info)
<   {
<     boost::shared_lock<boost::shared_mutex> rw_lock(id_info->calling_rw_mutex);
---
>         CallbackInterface::CallResult result = CallbackInterface::Invalid;
>         if (!info.marked_for_removal)
>         {
>           result = cb->call();
>         }
370,371c335
<     uint64_t last_calling = tls->calling_in_this_thread;
<     tls->calling_in_this_thread = id_info->id;
---
>         tls_->calling_in_this_thread = 0xffffffffffffffffULL;
373,381c337,349
<     CallbackInterface::CallResult result = CallbackInterface::Invalid;
<     if (info.marked_for_removal)
<     {
<       tls->cb_it = tls->callbacks.erase(tls->cb_it);
<     }
<     else
<     {
<       tls->cb_it = tls->callbacks.erase(tls->cb_it);
<       result = cb->call();
---
>         if (info.marked_for_removal || result == CallbackInterface::Success || result == CallbackInterface::Invalid)
>         {
>           it = tls_->callbacks.erase(it);
>         }
>         else if (result == CallbackInterface::TryAgain)
>         {
>           ++it;
>         }
>       }
>       else
>       {
>         it = tls_->callbacks.erase(it);
>       }
384,387c352,353
<     tls->calling_in_this_thread = last_calling;
< 
<     // Push TryAgain callbacks to the back of the shared queue
<     if (result == CallbackInterface::TryAgain && !info.marked_for_removal)
---
>     // If we had some callbacks that returned TryAgain, push them to the front of the shared queue
>     if (!tls_->callbacks.empty())
390,392c356,357
<       callbacks_.push_back(info);
< 
<       return TryAgain;
---
>       callbacks_.insert(callbacks_.begin(), tls_->callbacks.begin(), tls_->callbacks.end());
>       tls_->callbacks.clear();
394,395d358
< 
<     return Called;
397,402d359
<   else
<   {
<     tls->cb_it = tls->callbacks.erase(tls->cb_it);
<   }
< 
<   return Called;
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/CMakeLists.txt tmp/old/core/roscpp/src/libros/CMakeLists.txt
19c19
<                     connection.cpp
---
>                     connection.cpp 
22d21
<                     internal_timer_manager.cpp
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/common.cpp tmp/old/core/roscpp/src/libros/common.cpp
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43,44d40
< 
< #ifndef WIN32
47,48d42
< #endif //WIN32
< 
55d48
< #ifndef WIN32
61d53
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/connection.cpp tmp/old/core/roscpp/src/libros/connection.cpp
49a50
> , fixed_read_filled_(0)
58d58
< , sending_header_error_(false)
66c66
<   drop(Destructing);
---
>   drop();
89d88
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
93,98d91
< void Connection::removeDropListener(const boost::signals::connection& c)
< {
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<   c.disconnect();
< }
< 
117c110
<   while (!dropped_ && has_read_callback_)
---
>   if (fixed_read_filled_ < READ_BUFFER_SIZE)
119,144c112,120
<     ROS_ASSERT(read_buffer_);
<     uint32_t to_read = read_size_ - read_filled_;
<     if (to_read > 0)
<     {
<       int32_t bytes_read = transport_->read(read_buffer_.get() + read_filled_, to_read);
<       ROS_DEBUG_NAMED("superdebug", "Connection read %d bytes", bytes_read);
<       if (dropped_)
<       {
<         return;
<       }
<       else if (bytes_read < 0)
<       {
<         // Bad read, throw away results and report error
<         ReadFinishedFunc callback;
<         callback = read_callback_;
<         read_callback_.clear();
<         read_buffer_.reset();
<         uint32_t size = read_size_;
<         read_size_ = 0;
<         read_filled_ = 0;
<         has_read_callback_ = 0;
< 
<         if (callback)
<         {
<           callback(shared_from_this(), read_buffer_, size, false);
<         }
---
>     int32_t bytes_read = transport_->read(fixed_read_buffer_ + fixed_read_filled_, READ_BUFFER_SIZE - fixed_read_filled_);
>     ROS_DEBUG_NAMED("superdebug", "Connection read %d bytes", bytes_read);
>     if (dropped_)
>     {
>       return;
>     }
>     else if (bytes_read < 0)
>     {
>       reading_ = false;
146,147c122,136
<         break;
<       }
---
>       // Bad read, throw away results and report error
>       ReadFinishedFunc callback;
>       callback = read_callback_;
>       read_callback_ = ReadFinishedFunc();
>       read_buffer_ = boost::shared_array<uint8_t>();
>       uint32_t size = read_size_;
>       read_size_ = 0;
>       read_filled_ = 0;
>       has_read_callback_ = 0;
>       fixed_read_filled_ = 0;
> 
>       if (callback)
>         callback(shared_from_this(), read_buffer_, size, false);
>       return;
>     }
149c138,144
<       read_filled_ += bytes_read;
---
>     fixed_read_filled_ += bytes_read;
>   }
>   else
>   {
>     if (has_read_callback_)
>     {
>       ROS_WARN("Connection read buffer filled with no read callback set");
150a146,158
>   }
> 
>   while (has_read_callback_ && (fixed_read_filled_ > 0 || read_size_ == 0) && !dropped_)
>   {
>     ROS_ASSERT((int)read_size_ >= 0);
>     ROS_ASSERT((int)read_filled_ >= 0);
> 
>     uint32_t write_amount = std::min(read_size_ - read_filled_, fixed_read_filled_);
>     ROS_DEBUG_NAMED("superdebug", "Copying %d bytes into read buffer", write_amount);
>     memcpy(read_buffer_.get() + read_filled_, fixed_read_buffer_, write_amount);
>     memmove(fixed_read_buffer_, fixed_read_buffer_ + write_amount, fixed_read_filled_ - write_amount);
>     fixed_read_filled_ -= write_amount;
>     read_filled_ += write_amount;
152,154c160
<     ROS_ASSERT((int32_t)read_size_ >= 0);
<     ROS_ASSERT((int32_t)read_filled_ >= 0);
<     ROS_ASSERT_MSG(read_filled_ <= read_size_, "read_filled_ = %d, read_size_ = %d", read_filled_, read_size_);
---
>     ROS_ASSERT(read_filled_ <= read_size_);
168,169c174,175
<       read_callback_.clear();
<       read_buffer_.reset();
---
>       read_callback_ = ReadFinishedFunc();
>       read_buffer_ = boost::shared_array<uint8_t>();
177,185d182
<     else
<     {
<       break;
<     }
<   }
< 
<   if (!has_read_callback_)
<   {
<     transport_->disableRead();
264c261
<   if (dropped_ || sending_header_error_)
---
>   if (dropped_)
281,282d277
<   transport_->enableRead();
< 
289c284
<   if (dropped_ || sending_header_error_)
---
>   if (dropped_)
319c314
<   drop(TransportDisconnect);
---
>   drop();
322c317
< void Connection::drop(DropReason reason)
---
> void Connection::drop()
332c327
<       drop_signal_(shared_from_this(), reason);
---
>       drop_signal_(shared_from_this());
368c363
<   write(full_msg, msg_len, boost::bind(&Connection::onHeaderWritten, this, _1), false);
---
>   write(full_msg, msg_len, boost::bind(&Connection::onHeaderWritten, this, _1));
377d371
<   sending_header_error_ = true;
392c386
<     ROS_ERROR("a header of over a gigabyte was " \
---
>     ROS_ERROR("woah! a header of over a gigabyte was " \
395,396c389,390
<                 "synchronization is lost.");
<     conn->drop(HeaderError);
---
>                 "synchronization is lost... it's over.");
>     conn->drop();
412c406
<     drop(HeaderError);
---
>     drop();
420c414
<       drop(HeaderError);
---
>       drop();
428c422,425
<       header_func_(conn, header_);
---
>       if (!header_func_(conn, header_))
>       {
>         drop();
>       }
445c442
<   drop(HeaderError);
---
>   drop();
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/connection_manager.cpp tmp/old/core/roscpp/src/libros/connection_manager.cpp
36d35
< #include "ros/network.h"
76c75
<   if (!tcpserver_transport_->listen(network::getTCPROSPort(), MAX_TCPROS_CONN_QUEUE, boost::bind(&ConnectionManager::tcprosAcceptConnection, this, _1)))
---
>   if (!tcpserver_transport_->listen(0, MAX_TCPROS_CONN_QUEUE, boost::bind(&ConnectionManager::tcprosAcceptConnection, this, _1)))
78c77
<     ROS_FATAL("Listen on port [%d] failed", network::getTCPROSPort());
---
>     ROS_FATAL("Listen failed");
107c106
<   clear(Connection::Destructing);
---
>   clear();
110c109
< void ConnectionManager::clear(Connection::DropReason reason)
---
> void ConnectionManager::clear()
112,119c111,113
<   S_Connection local_connections;
<   {
<     boost::mutex::scoped_lock conn_lock(connections_mutex_);
<     local_connections.swap(connections_);
<   }
< 
<   for(S_Connection::iterator itr = local_connections.begin();
<       itr != local_connections.end();
---
>   boost::mutex::scoped_lock conn_lock(connections_mutex_);
>   for(S_Connection::iterator itr = connections_.begin();
>       itr != connections_.end();
123c117
<     conn->drop(reason);
---
>     conn->drop();
175a170,171
> 
>     size_t prev_size = connections_.size();
176a173
>     ROS_ASSERT(connections_.size() == (prev_size - 1));
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/file_log.cpp tmp/old/core/roscpp/src/libros/file_log.cpp
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
31,36d28
< 
< #ifdef WIN32
< #include <process.h>
< #include "log4cxx/helpers/transcoder.h"
< #endif //WIN32
< 
95,97d86
< #ifdef WIN32
< 	  int pid = _getpid();
< #else
99d87
< #endif //WIN32
141,143d128
< #ifdef WIN32
< 	  sprintf_s(pid_str, sizeof(pid_str), "%d", pid);
< #else
145d129
< #endif //WIN32
154,159d137
< #ifdef WIN32
< 	LOG4CXX_DECODE_CHAR(temp01, std::string("[%c] [%d] [thread %t]: [%p] %m\n"));
< 	log4cxx::LayoutPtr layout = new log4cxx::PatternLayout(temp01);
< 	LOG4CXX_DECODE_CHAR(temp02, log_file_name);
< 	log4cxx::RollingFileAppenderPtr appender = new log4cxx::RollingFileAppender(layout, temp02, false);
< #else
162d139
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/header.cpp tmp/old/core/roscpp/src/libros/header.cpp
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45d42
< #ifndef WIN32
47d43
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/init.cpp tmp/old/core/roscpp/src/libros/init.cpp
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
50d47
< #include "ros/subscribe_options.h"
52d48
< #include "ros/internal_timer_manager.h"
56d51
< #include "roscpp/Empty.h"
59a55
> #include <roslib/Time.h>
68,72d63
< #ifdef WIN32
< #include <process.h>
< #include "log4cxx/helpers/transcoder.h"
< #endif //WIN32
< 
113c104
< static boost::recursive_mutex g_shutting_down_mutex;
---
> static boost::mutex g_shutting_down_mutex;
130,143c121
<     // Since this gets run from within a mutex inside PollManager, we need to prevent ourselves from deadlocking with
<     // another thread that's already in the middle of shutdown()
<     boost::recursive_mutex::scoped_try_lock lock(g_shutting_down_mutex, boost::defer_lock);
<     while (!lock.try_lock() && !g_shutting_down)
<     {
<       ros::WallDuration(0.001).sleep();
<     }
< 
<     if (!g_shutting_down)
<     {
<       shutdown();
<     }
< 
<     g_shutdown_requested = false;
---
>     shutdown();
187,190d164
< #ifdef WIN32
<     LOG4CXX_ENCODE_CHAR(tmpstr, (*it)->getName());
< 	logger.name = tmpstr;
< #else
192d165
< #endif //WIN32
196,199d168
< #ifdef WIN32
< 	  LOG4CXX_ENCODE_CHAR(tmpstr, level->toString());
< 	  logger.level = tmpstr;
< #else
201d169
< #endif //WIN32
247c215
< bool closeAllConnections(roscpp::Empty::Request&, roscpp::Empty::Response&)
---
> void timeCallback(const roslib::Time::ConstPtr& msg)
249,251c217
<   ROSCPP_LOG_DEBUG("close_all_connections service called, closing connections");
<   ConnectionManager::instance()->clear(Connection::TransportDisconnect);
<   return true;
---
>   Time::setNow(msg->rostime);
304,316d269
<   bool enable_debug = false;
<   const char* enable_debug_env = getenv("ROSCPP_ENABLE_DEBUG");
<   if (enable_debug_env)
<   {
<     try
<     {
<       enable_debug = boost::lexical_cast<bool>(enable_debug_env);
<     }
<     catch (boost::bad_lexical_cast&)
<     {
<     }
<   }
< 
322,323d274
<   initInternalTimerManager();
< 
342,362c293
<   if (g_shutting_down) goto end;
< 
<   {
<     ros::AdvertiseServiceOptions ops;
<     ops.init<roscpp::GetLoggers>(names::resolve("~get_loggers"), getLoggers);
<     ops.callback_queue = getInternalCallbackQueue().get();
<     ServiceManager::instance()->advertiseService(ops);
<   }
< 
<   if (g_shutting_down) goto end;
< 
<   {
<     ros::AdvertiseServiceOptions ops;
<     ops.init<roscpp::SetLoggerLevel>(names::resolve("~set_logger_level"), setLoggerLevel);
<     ops.callback_queue = getInternalCallbackQueue().get();
<     ServiceManager::instance()->advertiseService(ops);
<   }
< 
<   if (g_shutting_down) goto end;
< 
<   if (enable_debug)
---
>   if (!g_shutting_down)
364,378d294
<     ros::AdvertiseServiceOptions ops;
<     ops.init<roscpp::Empty>(names::resolve("~debug/close_all_connections"), closeAllConnections);
<     ops.callback_queue = getInternalCallbackQueue().get();
<     ServiceManager::instance()->advertiseService(ops);
<   }
< 
<   if (g_shutting_down) goto end;
< 
<   {
<     bool use_sim_time = false;
<     param::param("/use_sim_time", use_sim_time, use_sim_time);
< 
<     ros::Time::init();
< 
<     if (use_sim_time)
380c296,299
<       Time::setNow(ros::Time());
---
>       ros::AdvertiseServiceOptions ops;
>       ops.init<roscpp::GetLoggers>(names::resolve("~get_loggers"), getLoggers);
>       ops.callback_queue = getInternalCallbackQueue().get();
>       ServiceManager::instance()->advertiseService(ops);
383,385c302
<     if (g_shutting_down) goto end;
< 
<     if (use_sim_time)
---
>     if (!g_shutting_down)
387,390c304,341
<       ros::SubscribeOptions ops;
<       ops.init<roslib::Clock>("/clock", 1, clockCallback);
<       ops.callback_queue = getInternalCallbackQueue().get();
<       TopicManager::instance()->subscribe(ops);
---
>       {
>         ros::AdvertiseServiceOptions ops;
>         ops.init<roscpp::SetLoggerLevel>(names::resolve("~set_logger_level"), setLoggerLevel);
>         ops.callback_queue = getInternalCallbackQueue().get();
>         ServiceManager::instance()->advertiseService(ops);
>       }
> 
>       if (!g_shutting_down)
>       {
>         bool use_sim_time = false;
>         param::param("/use_sim_time", use_sim_time, use_sim_time);
>         if (use_sim_time)
>         {
>           Time::setNow(ros::Time());
>         }
> 
>         if (!g_shutting_down)
>         {
>           {
>             ros::SubscribeOptions ops;
>             ops.init<roslib::Time>("/time", 1, timeCallback);
>             ops.callback_queue = getInternalCallbackQueue().get();
>             TopicManager::instance()->subscribe(ops);
>           }
> 
>           {
>             ros::SubscribeOptions ops;
>             ops.init<roslib::Clock>("/clock", 1, clockCallback);
>             ops.callback_queue = getInternalCallbackQueue().get();
>             TopicManager::instance()->subscribe(ops);
>           }
> 
>           g_internal_queue_thread = boost::thread(internalCallbackQueueThreadFunc);
>           getGlobalCallbackQueue()->enable();
> 
>           ROSCPP_LOG_DEBUG("Started node [%s], pid [%d], bound on [%s], xmlrpc port [%d], tcpros port [%d], logging to [%s], using [%s] time", this_node::getName().c_str(), getpid(), network::getHost().c_str(), XMLRPCManager::instance()->getServerPort(), ConnectionManager::instance()->getTCPPort(), file_log::getLogFilename().c_str(), Time::useSystemTime() ? "real" : "sim");
>         }
>       }
394,407d344
<   if (g_shutting_down) goto end;
< 
<   g_internal_queue_thread = boost::thread(internalCallbackQueueThreadFunc);
<   getGlobalCallbackQueue()->enable();
< 
< #ifdef WIN32
<   ROSCPP_LOG_DEBUG("Started node [%s], pid [%d], bound on [%s], xmlrpc port [%d], tcpros port [%d], logging to [%s], using [%s] time", this_node::getName().c_str(), _getpid(), network::getHost().c_str(), XMLRPCManager::instance()->getServerPort(), ConnectionManager::instance()->getTCPPort(), file_log::getLogFilename().c_str(), Time::useSystemTime() ? "real" : "sim");
< #else
<   ROSCPP_LOG_DEBUG("Started node [%s], pid [%d], bound on [%s], xmlrpc port [%d], tcpros port [%d], logging to [%s], using [%s] time", this_node::getName().c_str(), getpid(), network::getHost().c_str(), XMLRPCManager::instance()->getServerPort(), ConnectionManager::instance()->getTCPPort(), file_log::getLogFilename().c_str(), Time::useSystemTime() ? "real" : "sim");
< #endif //WIN32
< 
<   // Label used to abort if we've started shutting down in the middle of start(), which can happen in
<   // threaded code or if Ctrl-C is pressed while we're initializing
< end:
411c348
<     boost::recursive_mutex::scoped_lock lock(g_shutting_down_mutex);
---
>     boost::mutex::scoped_lock lock(g_shutting_down_mutex);
434,437c371
<     // Disable SIGPIPE
< #ifndef WIN32
<     signal(SIGPIPE, SIG_IGN);
< #endif //WIN32
---
>     ros::Time::init();
495c429
< void removeROSArgs(int argc, const char* const* argv, V_string& args_out)
---
> void removeROSArgs(int argc, const char** argv, V_string& args_out)
544c478
<   boost::recursive_mutex::scoped_lock lock(g_shutting_down_mutex);
---
>   boost::mutex::scoped_lock lock(g_shutting_down_mutex);
570d503
<     PollManager::instance()->shutdown();
571a505
>     PollManager::instance()->shutdown();
Only in tmp/msvc/core/roscpp/src/libros: internal_timer_manager.cpp
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/intraprocess_publisher_link.cpp tmp/old/core/roscpp/src/libros/intraprocess_publisher_link.cpp
73,75c73,74
<   (*values)["type"] = publisher->getDataType();
<   (*values)["md5sum"] = publisher->getMD5Sum();
<   (*values)["message_definition"] = publisher->getMessageDefinition();
---
>   (*values)["type"] = parent->datatype();
>   (*values)["md5sum"] = parent->md5sum();
81a81
>   if (dropped_)
83,89c83
<     boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<     if (dropped_)
<     {
<       return;
<     }
< 
<     dropped_ = true;
---
>     return;
91a86,87
>   dropped_ = true;
> 
95d90
<     publisher_.reset();
106c101
< void IntraProcessPublisherLink::handleMessage(const SerializedMessage& m, bool ser, bool nocopy)
---
> void IntraProcessPublisherLink::handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes)
108,114c103
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<   if (dropped_)
<   {
<     return;
<   }
< 
<   stats_.bytes_received_ += m.num_bytes;
---
>   stats_.bytes_received_ += num_bytes;
121c110
<     stats_.drops_ += parent->handleMessage(m, ser, nocopy, header_.getValues(), shared_from_this());
---
>     stats_.drops_ += parent->handleMessage(buffer, num_bytes, true, header_.getValues(), shared_from_this());
130,151d118
< void IntraProcessPublisherLink::getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti)
< {
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<   if (dropped_)
<   {
<     ser = false;
<     nocopy = false;
<     return;
<   }
< 
<   SubscriptionPtr parent = parent_.lock();
<   if (parent)
<   {
<     parent->getPublishTypes(ser, nocopy, ti);
<   }
<   else
<   {
<     ser = true;
<     nocopy = false;
<   }
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/intraprocess_subscriber_link.cpp tmp/old/core/roscpp/src/libros/intraprocess_subscriber_link.cpp
74c74
< void IntraProcessSubscriberLink::enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy)
---
> bool IntraProcessSubscriberLink::publish(const Message& m)
76,77c76
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<   if (dropped_)
---
>   if (!verifyDatatype(m.__getDataType()))
79c78,88
<     return;
---
>     return false;
>   }
> 
>   uint32_t msg_len = m.serializationLength();
>   boost::shared_array<uint8_t> buf = boost::shared_array<uint8_t>(new uint8_t[msg_len]);
>   *((uint32_t*)buf.get()) = msg_len;
> 
>   int seq = 0;
>   if (PublicationPtr parent = parent_.lock())
>   {
>     seq = parent->getSequence();
81a91,100
>   m.serialize(buf.get(), seq);
> 
>   ROS_ASSERT(subscriber_);
>   subscriber_->handleMessage(buf, msg_len);
> 
>   return true;
> }
> 
> void IntraProcessSubscriberLink::enqueueMessage(const SerializedMessage& m)
> {
83c102
<   subscriber_->handleMessage(m, ser, nocopy);
---
>   subscriber_->handleMessage(m.buf, m.num_bytes);
92a112
>   if (dropped_)
94,100c114
<     boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<     if (dropped_)
<     {
<       return;
<     }
< 
<     dropped_ = true;
---
>     return;
106d119
<     subscriber_.reset();
117,127d129
< void IntraProcessSubscriberLink::getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti)
< {
<   boost::recursive_mutex::scoped_lock lock(drop_mutex_);
<   if (dropped_)
<   {
<     return;
<   }
< 
<   subscriber_->getPublishTypes(ser, nocopy, ti);
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/master.cpp tmp/old/core/roscpp/src/libros/master.cpp
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
101,116d98
< #ifdef WIN32
< void setURI(const std::string uri)
< {
< 	g_uri = uri;
< }
< 
< void setHost(const std::string host)
< {
< 	g_host = host;
< }
< 
< void setPort(const uint32_t port)
< {
< 	g_port = port;
< }
< #endif //Win32
143c125
<     topics.push_back(TopicInfo(std::string(payload[i][0]), std::string(payload[i][1])));
---
>     topics.push_back(TopicInfo(std::string(payload[i][0]), std::string(payload[i][1]), std::string(payload[i][1])));
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/message_deserializer.cpp tmp/old/core/roscpp/src/libros/message_deserializer.cpp
30d29
< #include "ros/subscription_callback_helper.h"
36c35
< MessageDeserializer::MessageDeserializer(const SubscriptionCallbackHelperPtr& helper, const SerializedMessage& m, const boost::shared_ptr<M_string>& connection_header)
---
> MessageDeserializer::MessageDeserializer(const SubscriptionMessageHelperPtr& helper, const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header)
38c37,39
< , serialized_message_(m)
---
> , buffer_(buffer)
> , num_bytes_(num_bytes)
> , buffer_includes_size_header_(buffer_includes_size_header)
41,44c42
<   if (serialized_message_.message && *serialized_message_.type_info != helper->getTypeInfo())
<   {
<     serialized_message_.message.reset();
<   }
---
> 
47c45
< VoidConstPtr MessageDeserializer::deserialize()
---
> MessagePtr MessageDeserializer::deserialize()
56c54
<   if (serialized_message_.message)
---
>   if (!buffer_ && num_bytes_ > 0)
58,59c56,57
<     msg_ = serialized_message_.message;
<     return msg_;
---
>     // If the buffer has been reset it means we tried to deserialize and failed
>     return MessagePtr();
62c60,62
<   if (!serialized_message_.buf && serialized_message_.num_bytes > 0)
---
>   msg_ = helper_->create();
>   msg_->__serialized_length = num_bytes_;
>   if (buffer_includes_size_header_)
64,65c64
<     // If the buffer has been reset it means we tried to deserialize and failed
<     return VoidConstPtr();
---
>     msg_->__serialized_length -= 4;
66a66
>   msg_->__connection_header = connection_header_;
70,74c70,75
<     SubscriptionCallbackHelperDeserializeParams params;
<     params.buffer = serialized_message_.message_start;
<     params.length = serialized_message_.num_bytes - (serialized_message_.message_start - serialized_message_.buf.get());
<     params.connection_header = connection_header_;
<     msg_ = helper_->deserialize(params);
---
>     uint8_t* raw_buffer = buffer_.get();
>     if (buffer_includes_size_header_)
>     {
>       raw_buffer += 4;
>     }
>     msg_->deserialize(raw_buffer);
78c79
<     ROS_ERROR("Exception thrown when deserializing message of length [%d] from [%s]: %s", (uint32_t)serialized_message_.num_bytes, (*connection_header_)["callerid"].c_str(), e.what());
---
>     ROS_ERROR("Exception thrown when deserializing message of length [%d] from [%s]: %s", num_bytes_, (*connection_header_)["callerid"].c_str(), e.what());
81c82
<   serialized_message_.buf.reset();
---
>   buffer_.reset();
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/network.cpp tmp/old/core/roscpp/src/libros/network.cpp
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33d30
< #include "ros/exceptions.h"
38d34
< #ifndef WIN32
42d37
< #endif //WIN32
48,49d42
< #include <boost/lexical_cast.hpp>
< 
57d49
< uint16_t g_tcpros_server_port = 0;
64,70d55
< #ifdef WIN32
< void setHost( const std::string host)
< {
<   g_host = host;
< }
< #endif //WIN32
< 
91,95d75
< uint16_t getTCPROSPort()
< {
<   return g_tcpros_server_port;
< }
< 
213,225d192
<   it = remappings.find("__tcpros_server_port");
<   if (it != remappings.end())
<   {
<     try
<     {
<       g_tcpros_server_port = boost::lexical_cast<uint16_t>(it->second);
<     }
<     catch (boost::bad_lexical_cast&)
<     {
<       throw ros::InvalidPortException("__tcpros_server_port [" + it->second + "] was not specified as a number within the 0-65535 range");
<     }
<   }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/node_handle.cpp tmp/old/core/roscpp/src/libros/node_handle.cpp
87,89d86
< 
<   remappings_ = parent.remappings_;
<   unresolved_remappings_ = parent.unresolved_remappings_;
109d105
<   unresolved_remappings_ = rhs.unresolved_remappings_;
125d120
<   unresolved_remappings_ = rhs.unresolved_remappings_;
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/param.cpp tmp/old/core/roscpp/src/libros/param.cpp
173c173
<       if (it != g_params.end())
---
>       if (it != g_params.end() && it->second.valid())
175,177c175
<         if (it->second.valid())
<         {
<           ROS_DEBUG_NAMED("cached_parameters", "Using cached parameter value for key [%s]", mapped_key.c_str());
---
>         ROS_DEBUG_NAMED("cached_parameters", "Using cached parameter value for key [%s]", mapped_key.c_str());
179,186c177,178
<           v = it->second;
<           return true;
<         }
<         else
<         {
<           ROS_DEBUG_NAMED("cached_parameters", "Cached parameter is invalid for key [%s]", mapped_key.c_str());
<           return false;
<         }
---
>         v = it->second;
>         return true;
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/poll_manager.cpp tmp/old/core/roscpp/src/libros/poll_manager.cpp
82a83,85
>   // Disable SIGPIPE, period
>   signal(SIGPIPE, SIG_IGN);
> 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/poll_set.cpp tmp/old/core/roscpp/src/libros/poll_set.cpp
35,41d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #include <winsock2.h>
< #include <io.h>
< #endif //WIN32
< 
51d43
< #ifndef WIN32
55d46
< #endif //WIN32
64,80d54
< #ifdef WIN32
<   HANDLE pipe_rd, pipe_wr;
<   int rc = CreatePipe(&pipe_rd, &pipe_wr, NULL, 0);
< 
<   if(!rc)
<   {
< 	  ROS_FATAL("CreatePipe() failed");
< 	  ROS_BREAK();
<   }
<   signal_pipe_[0] = _open_osfhandle((intptr_t) pipe_rd, O_RDONLY|O_TEXT) ;
<   signal_pipe_[1] = _open_osfhandle((intptr_t) pipe_wr, O_WRONLY|O_TEXT) ;
<   if (0 > signal_pipe_[0] || signal_pipe_[1] < 0)
<   {
< 	  ROS_FATAL("_open_osfhandle() failed");
< 	  ROS_BREAK();
<   }
< #else
100c74
< #endif //WIN32
---
> 
107,110d80
< #ifdef WIN32
<   ::closesocket(signal_pipe_[0]);
<   ::closesocket(signal_pipe_[1]);
< #else
113d82
< #endif //WIN32
155,159d123
<     {
<       boost::mutex::scoped_lock lock(just_deleted_mutex_);
<       just_deleted_.push_back(fd);
<     }
< 
218,223d181
< #ifdef WIN32
< 	if (_write(signal_pipe_[1], &b, 1) < 0)
<     {
<       // do nothing... this prevents warnings on gcc 4.3
<     }
< #else
228d185
< #endif //WIN32
238d194
<   size_t ufds_count = ufds_.size();
240,250c196
< #ifdef WIN32
<   if((ret = WSAPoll(&ufds_.front(), ufds_count, poll_timeout)) < 0)
<   {
<     // WSAEINTR means that we got interrupted by a signal, and is not an
<     // error.
<     if(WSAGetLastError() != WSAEINTR)
<     {
<       ROS_ERROR("poll failed with error [%d]", WSAGetLastError());
<     }
<   }
< #else
---
>   size_t ufds_count = ufds_.size();
260d205
< #endif //WIN32
291,298c236
<       // If these are registered events for this socket, OR the events are ERR/HUP/NVAL,
<       // call through to the registered function
<       int revents = ufds_[i].revents;
<       if (func
<           && ((events & revents)
<               || (revents & POLLERR)
<               || (revents & POLLHUP)
<               || (revents & POLLNVAL)))
---
>       if (func && (events & ufds_[i].revents))
300,318c238
<         bool skip = false;
<         if (revents & (POLLNVAL|POLLERR|POLLHUP))
<         {
<           // If a socket was just closed and then the file descriptor immediately reused, we can
<           // get in here with what we think is a valid socket (since it was just re-added to our set)
<           // but which is actually referring to the previous fd with the same #.  If this is the case,
<           // we ignore the first instance of one of these errors.  If it's a real error we'll
<           // hit it again next time through.
<           boost::mutex::scoped_lock lock(just_deleted_mutex_);
<           if (std::find(just_deleted_.begin(), just_deleted_.end(), ufds_[i].fd) != just_deleted_.end())
<           {
<             skip = true;
<           }
<         }
< 
<         if (!skip)
<         {
<           func(revents & (events|POLLERR|POLLHUP|POLLNVAL));
<         }
---
>         func(ufds_[i].revents & events);
323,325d242
< 
<     boost::mutex::scoped_lock lock(just_deleted_mutex_);
<     just_deleted_.clear();
357,362d273
< #ifdef WIN32
< 	while(_read(signal_pipe_[0], &b, 1) > 0)
<     {
<       //do nothing keep draining
<     };
< #else
367d277
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/publication.cpp tmp/old/core/roscpp/src/libros/publication.cpp
33,34d32
< #include "ros/serialization.h"
< #include <roslib/Header.h>
39,75d36
< class PeerConnDisconnCallback : public CallbackInterface
< {
< public:
<   PeerConnDisconnCallback(const SubscriberStatusCallback& callback, const SubscriberLinkPtr& sub_link, bool use_tracked_object, const VoidConstWPtr& tracked_object)
<   : callback_(callback)
<   , sub_link_(sub_link)
<   , use_tracked_object_(use_tracked_object)
<   , tracked_object_(tracked_object)
<   {
<   }
< 
<   virtual CallResult call()
<   {
<     VoidConstPtr tracker;
<     if (use_tracked_object_)
<     {
<       tracker = tracked_object_.lock();
< 
<       if (!tracker)
<       {
<         return Invalid;
<       }
<     }
< 
<     SingleSubscriberPublisher pub(sub_link_);
<     callback_(pub);
< 
<     return Success;
<   }
< 
< private:
<   SubscriberStatusCallback callback_;
<   SubscriberLinkPtr sub_link_;
<   bool use_tracked_object_;
<   VoidConstWPtr tracked_object_;
< };
< 
81,82c42
<                          bool latch,
<                          bool has_header)
---
>                          bool latch)
90,92c50
<   latch_(latch),
<   has_header_(has_header),
<   intraprocess_subscriber_count_(0)
---
>   latch_(latch)
106,119d63
< 
<   // Add connect callbacks for all current subscriptions if this publisher wants them
<   if (callbacks->connect_ && callbacks->callback_queue_)
<   {
<     boost::mutex::scoped_lock lock(subscriber_links_mutex_);
<     V_SubscriberLink::iterator it = subscriber_links_.begin();
<     V_SubscriberLink::iterator end = subscriber_links_.end();
<     for (; it != end; ++it)
<     {
<       const SubscriberLinkPtr& sub_link = *it;
<       CallbackInterfacePtr cb(new PeerConnDisconnCallback(callbacks->connect_, sub_link, callbacks->has_tracked_object_, callbacks->tracked_object_));
<       callbacks->callback_queue_->addCallback(cb, (uint64_t)callbacks.get());
<     }
<   }
143,144c87
<     boost::mutex::scoped_lock lock(publish_queue_mutex_);
<     boost::mutex::scoped_lock lock2(subscriber_links_mutex_);
---
>     boost::mutex::scoped_lock lock(subscriber_links_mutex_);
165,180d107
<   ROS_ASSERT(m.buf);
< 
<   uint32_t seq = incrementSequence();
<   if (has_header_)
<   {
<     // If we have a header, we know it's immediately after the message length
<     // Deserialize it, write the sequence, and then serialize it again.
<     namespace ser = ros::serialization;
<     roslib::Header header;
<     ser::IStream istream(m.buf.get() + 4, m.num_bytes - 4);
<     ser::deserialize(istream, header);
<     header.seq = seq;
<     ser::OStream ostream(m.buf.get() + 4, m.num_bytes - 4);
<     ser::serialize(ostream, header);
<   }
< 
185c112
<     sub_link->enqueueMessage(m, true, false);
---
>     sub_link->enqueueMessage(m);
207,211d133
< 
<     if (sub_link->isIntraprocess())
<     {
<       ++intraprocess_subscriber_count_;
<     }
216c138
<     sub_link->enqueueMessage(last_message_, true, true);
---
>     sub_link->enqueueMessage(last_message_);
236,240d157
<     if (sub_link->isIntraprocess())
<     {
<       --intraprocess_subscriber_count_;
<     }
< 
325a243,279
> class PeerConnDisconnCallback : public CallbackInterface
> {
> public:
>   PeerConnDisconnCallback(const SubscriberStatusCallback& callback, const SubscriberLinkPtr& sub_link, bool use_tracked_object, const VoidWPtr& tracked_object)
>   : callback_(callback)
>   , sub_link_(sub_link)
>   , use_tracked_object_(use_tracked_object)
>   , tracked_object_(tracked_object)
>   {
>   }
> 
>   virtual CallResult call()
>   {
>     VoidPtr tracker;
>     if (use_tracked_object_)
>     {
>       tracker = tracked_object_.lock();
> 
>       if (!tracker)
>       {
>         return Invalid;
>       }
>     }
> 
>     SingleSubscriberPublisher pub(sub_link_);
>     callback_(pub);
> 
>     return Success;
>   }
> 
> private:
>   SubscriberStatusCallback callback_;
>   SubscriberLinkPtr sub_link_;
>   bool use_tracked_object_;
>   VoidWPtr tracked_object_;
> };
> 
362,507d315
< uint32_t Publication::incrementSequence()
< {
<   boost::mutex::scoped_lock lock(seq_mutex_);
<   uint32_t old_seq = seq_;
<   ++seq_;
< 
<   return old_seq;
< }
< 
< uint32_t Publication::getNumSubscribers()
< {
<   boost::mutex::scoped_lock lock(subscriber_links_mutex_);
<   return (uint32_t)subscriber_links_.size();
< }
< 
< void Publication::getPublishTypes(bool& serialize, bool& nocopy, const std::type_info& ti)
< {
<   boost::mutex::scoped_lock lock(subscriber_links_mutex_);
<   V_SubscriberLink::const_iterator it = subscriber_links_.begin();
<   V_SubscriberLink::const_iterator end = subscriber_links_.end();
<   for (; it != end; ++it)
<   {
<     const SubscriberLinkPtr& sub = *it;
<     bool s = false;
<     bool n = false;
<     sub->getPublishTypes(s, n, ti);
<     serialize = serialize || s;
<     nocopy = nocopy || n;
< 
<     if (serialize && nocopy)
<     {
<       break;
<     }
<   }
< }
< 
< bool Publication::hasSubscribers()
< {
<   boost::mutex::scoped_lock lock(subscriber_links_mutex_);
<   return !subscriber_links_.empty();
< }
< 
< void Publication::publish(SerializedMessage& m)
< {
<   if (m.message)
<   {
<     boost::mutex::scoped_lock lock(subscriber_links_mutex_);
<     V_SubscriberLink::const_iterator it = subscriber_links_.begin();
<     V_SubscriberLink::const_iterator end = subscriber_links_.end();
<     for (; it != end; ++it)
<     {
<       const SubscriberLinkPtr& sub = *it;
<       if (sub->isIntraprocess())
<       {
<         sub->enqueueMessage(m, false, true);
<       }
<     }
< 
<     m.message.reset();
<   }
< 
<   if (m.buf)
<   {
<     boost::mutex::scoped_lock lock(publish_queue_mutex_);
<     publish_queue_.push_back(m);
<   }
< }
< 
< void Publication::processPublishQueue()
< {
<   V_SerializedMessage queue;
<   {
<     boost::mutex::scoped_lock lock(publish_queue_mutex_);
< 
<     if (dropped_)
<     {
<       return;
<     }
< 
<     queue.insert(queue.end(), publish_queue_.begin(), publish_queue_.end());
<     publish_queue_.clear();
<   }
< 
<   if (queue.empty())
<   {
<     return;
<   }
< 
<   V_SerializedMessage::iterator it = queue.begin();
<   V_SerializedMessage::iterator end = queue.end();
<   for (; it != end; ++it)
<   {
<     enqueueMessage(*it);
<   }
< }
< 
< bool Publication::validateHeader(const Header& header, std::string& error_msg)
< {
<   std::string md5sum, topic, client_callerid;
<   if (!header.getValue("md5sum", md5sum)
<    || !header.getValue("topic", topic)
<    || !header.getValue("callerid", client_callerid))
<   {
<     std::string msg("Header from subscriber did not have the required elements: md5sum, topic, callerid");
< 
<     ROS_ERROR("%s", msg.c_str());
<     error_msg = msg;
< 
<     return false;
<   }
< 
<   // Check whether the topic has been deleted from
<   // advertised_topics through a call to unadvertise(), which could
<   // have happened while we were waiting for the subscriber to
<   // provide the md5sum.
<   if(isDropped())
<   {
<     std::string msg = std::string("received a tcpros connection for a nonexistent topic [") +
<                 topic + std::string("] from [" + client_callerid +"].");
< 
<     ROS_ERROR("%s", msg.c_str());
<     error_msg = msg;
< 
<     return false;
<   }
< 
<   if (getMD5Sum() != md5sum &&
<       (md5sum != std::string("*") && getMD5Sum() != std::string("*")))
<   {
<     std::string datatype;
<     header.getValue("type", datatype);
< 
<     std::string msg = std::string("Client [") + client_callerid + std::string("] wants topic ") + topic +
<                       std::string(" to have datatype/md5sum [") + datatype + "/" + md5sum +
<                       std::string("], but our version has [") + getDataType() + "/" + getMD5Sum() +
<                       std::string("]. Dropping connection.");
< 
<     ROS_ERROR("%s", msg.c_str());
<     error_msg = msg;
< 
<     return false;
<   }
< 
<   return true;
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/publisher.cpp tmp/old/core/roscpp/src/libros/publisher.cpp
79c79
< void Publisher::publish(const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m) const
---
> void Publisher::publish(const MessageConstPtr& message) const
83c83
<     ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
---
>     ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher");
87,91c87,91
<   if (!impl_->isValid())
<   {
<     ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<     return;
<   }
---
>  if (!impl_->isValid())
>  {
>    ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
>    return;
>  }
93c93
<   TopicManager::instance()->publish(impl_->topic_, serfunc, m);
---
>   TopicManager::instance()->publish(impl_->topic_, *message);
96c96
< void Publisher::incrementSequence() const
---
> void Publisher::publish(const Message& message) const
98c98
<   if (impl_ && impl_->isValid())
---
>   if (!impl_)
100c100,107
<     TopicManager::instance()->incrementSequence(impl_->topic_);
---
>     ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher");
>     return;
>   }
> 
>   if (!impl_->isValid())
>   {
>    ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
>    return;
101a109,110
> 
>   TopicManager::instance()->publish(impl_->topic_, message);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/publisher_link.cpp tmp/old/core/roscpp/src/libros/publisher_link.cpp
70c70
<     ROS_ERROR("Publisher header did not have required element: md5sum");
---
>     ROS_ERROR("Publisher TCPROS header did not have required element: md5sum");
74,75d73
<   md5sum_ = md5sum;
< 
78c76
<     ROS_ERROR("Publisher header did not have required element: type");
---
>     ROS_ERROR("Publisher TCPROS header did not have required element: type");
94,98d91
<   if (SubscriptionPtr parent = parent_.lock())
<   {
<     parent->headerReceived(shared_from_this(), header);
<   }
< 
107,112d99
< const std::string& PublisherLink::getMD5Sum()
< {
<   ROS_ASSERT(!md5sum_.empty());
<   return md5sum_;
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/rosout_appender.cpp tmp/old/core/roscpp/src/libros/rosout_appender.cpp
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
46,49d43
< #ifdef WIN32
< #include <log4cxx/helpers/transcoder.h>
< #endif //WIN32
< 
83a78
> 
88,91c83
< 	msg->level = roslib::Log::FATAL;
< #ifdef WIN32
< 	LOG4CXX_ENCODE_CHAR(last_error_, event->getMessage());
< #else
---
>     msg->level = roslib::Log::FATAL;
93d84
< #endif //WIN32
97,101c88
< #ifdef WIN32
< 	msg->level = roslib::Log::ERR;
< 	LOG4CXX_ENCODE_CHAR(last_error_, event->getMessage());
< #else
< 	msg->level = roslib::Log::ERROR;
---
>     msg->level = roslib::Log::ERROR;
103d89
< #endif //WIN32
108d93
< 
120,123d104
< #ifdef WIN32
<   LOG4CXX_ENCODE_CHAR(tempmsg, event->getMessage());
<   msg->msg = tempmsg;
< #else
125d105
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service_client.cpp tmp/old/core/roscpp/src/libros/service_client.cpp
58c58
<       server_link_->getConnection()->drop(Connection::Destructing);
---
>       server_link_->getConnection()->drop();
109c109
< bool ServiceClient::call(const SerializedMessage& req, SerializedMessage& resp, const std::string& service_md5sum)
---
> bool ServiceClient::call(Message& req, Message& resp, const std::string& service_md5sum)
144c144
<   bool ret = link->call(req, resp);
---
>   bool ret = link->call(&req, &resp);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service_client_link.cpp tmp/old/core/roscpp/src/libros/service_client_link.cpp
50d49
< : persistent_(false)
56,66d54
<   if (connection_)
<   {
<     if (connection_->isSendingHeaderError())
<     {
<       connection_->removeDropListener(dropped_conn_);
<     }
<     else
<     {
<       connection_->drop(Connection::Destructing);
<     }
<   }
72c60
<   dropped_conn_ = connection_->addDropListener(boost::bind(&ServiceClientLink::onConnectionDropped, this, _1));
---
>   connection_->addDropListener(boost::bind(&ServiceClientLink::onConnectionDropped, this, _1));
93,101d80
<   std::string persistent;
<   if (header.getValue("persistent", persistent))
<   {
<     if (persistent == "1" || persistent == "true")
<     {
<       persistent_ = true;
<     }
<   }
< 
190c169
<     ROS_ERROR("a message of over a gigabyte was " \
---
>     ROS_ERROR("woah! a message of over a gigabyte was " \
193,195c172,173
<                 "synchronization is lost.");
<     conn->drop(Connection::Destructing);
<     return;
---
>                 "synchronization is lost... it's over.");
>     conn->drop();
222c200,208
<   if (persistent_)
---
>   connection_->read(4, boost::bind(&ServiceClientLink::onRequestLength, this, _1, _2, _3, _4));
> }
> 
> void ServiceClientLink::processResponse(bool ok, const MessagePtr& resp)
> {
>   boost::shared_array<uint8_t> buf;
>   uint32_t num_bytes = 0;
> 
>   if (ok)
224c210,215
<     connection_->read(4, boost::bind(&ServiceClientLink::onRequestLength, this, _1, _2, _3, _4));
---
>     int msg_len = resp->serializationLength();
>     buf = boost::shared_array<uint8_t>(new uint8_t[msg_len + 5]);
>     buf[0] = 1;
>     memcpy(buf.get() + 1, &msg_len, 4);
>     resp->serialize(buf.get() + 5, 0);
>     num_bytes = msg_len + 5;
228c219,225
<     connection_->drop(Connection::Destructing);
---
>     buf = boost::shared_array<uint8_t>(new uint8_t[5]);
>     buf[0] = 0;
>     buf[1] = 0;
>     buf[2] = 0;
>     buf[3] = 0;
>     buf[4] = 0;
>     num_bytes = 5;
230d226
< }
232,234c228
< void ServiceClientLink::processResponse(bool ok, const SerializedMessage& res)
< {
<   connection_->write(res.buf, res.num_bytes, boost::bind(&ServiceClientLink::onResponseWritten, this, _1));
---
>   connection_->write(buf, num_bytes, boost::bind(&ServiceClientLink::onResponseWritten, this, _1));
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service.cpp tmp/old/core/roscpp/src/libros/service.cpp
37d36
< #include "ros/header.h"
50c49
<     TransportTCPPtr transport(new TransportTCP(0, TransportTCP::SYNCHRONOUS));
---
>     TransportTCPPtr transport(new TransportTCP(&PollManager::instance()->getPollSet()));
54,63d52
<       M_string m;
<       m["probe"] = "1";
<       m["md5sum"] = "*";
<       m["callerid"] = this_node::getName();
<       m["service"] = mapped_name;
<       boost::shared_array<uint8_t> buffer;
<       uint32_t size = 0;;
<       Header::write(m, buffer, size);
<       transport->write((uint8_t*)&size, sizeof(size));
<       transport->write(buffer.get(), size);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service_manager.cpp tmp/old/core/roscpp/src/libros/service_manager.cpp
93c93
<   boost::recursive_mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
---
>   boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
126c126
<       (*it)->getConnection()->drop(Connection::Destructing);
---
>       (*it)->getConnection()->drop();
136c136
<   boost::recursive_mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
---
>   boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
170c170
<   boost::recursive_mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
---
>   boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
252c252
<   boost::recursive_mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
---
>   boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
297c297
<   boost::recursive_mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
---
>   boost::mutex::scoped_lock shutdown_lock(shutting_down_mutex_);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service_publication.cpp tmp/old/core/roscpp/src/libros/service_publication.cpp
46,47c46,47
<                              const std::string& response_data_type, const ServiceCallbackHelperPtr& helper, CallbackQueueInterface* callback_queue,
<                              const VoidConstPtr& tracked_object)
---
>                              const std::string& response_data_type, const ServiceMessageHelperPtr& helper, CallbackQueueInterface* callback_queue,
>                              const VoidPtr& tracked_object)
87c87
<   ServiceCallback(const ServiceCallbackHelperPtr& helper, const boost::shared_array<uint8_t>& buf, size_t num_bytes, const ServiceClientLinkPtr& link, bool has_tracked_object, const VoidConstWPtr& tracked_object)
---
>   ServiceCallback(const ServiceMessageHelperPtr& helper, const boost::shared_array<uint8_t>& buf, size_t num_bytes, const ServiceClientLinkPtr& link, bool has_tracked_object, const VoidWPtr& tracked_object)
104c104
<     VoidConstPtr tracker;
---
>     VoidPtr tracker;
111,112c111
<         SerializedMessage res = serialization::serializeServiceResponse(false, 0);
<         link_->processResponse(false, res);
---
>         link_->processResponse(false, MessagePtr());
117,121c116,117
<     ServiceCallbackHelperCallParams params;
<     params.request = SerializedMessage(buffer_, num_bytes_);
<     params.connection_header = link_->getConnection()->getHeader().getValues();
<     try
<     {
---
>     MessagePtr req = helper_->createRequest();
>     MessagePtr resp = helper_->createResponse();
123,132c119,124
<       bool ok = helper_->call(params);
<       link_->processResponse(ok, params.response);
<     }
<     catch (std::exception& e)
<     {
<       ROS_ERROR("Exception thrown while processing service call: %s", e.what());
<       SerializedMessage res = serialization::serializeServiceResponse(false, 0);
<       link_->processResponse(false, res);
<       return Invalid;
<     }
---
>     req->__connection_header = link_->getConnection()->getHeader().getValues();
> 
>     req->__serialized_length = num_bytes_;
>     req->deserialize(buffer_.get());
>     bool ok = helper_->call(req, resp);
>     link_->processResponse(ok, resp);
138c130
<   ServiceCallbackHelperPtr helper_;
---
>   ServiceMessageHelperPtr helper_;
143c135
<   VoidConstWPtr tracked_object_;
---
>   VoidWPtr tracked_object_;
185c177
<     (*i)->getConnection()->drop(Connection::Destructing);
---
>     (*i)->getConnection()->drop();
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/service_server_link.cpp tmp/old/core/roscpp/src/libros/service_server_link.cpp
74a75
>     local->success_ = false;
124d124
<   header["persistent"] = persistent_ ? "1" : "0";
180d179
<   //ros::WallDuration(0.1).sleep();
197c196
<     ROS_ERROR("a message of over a gigabyte was " \
---
>     ROS_ERROR("woah! a message of over a gigabyte was " \
200,201c199,200
<                 "synchronization is lost.");
<     conn->drop(Connection::Destructing);
---
>                 "synchronization is lost... it's over.");
>     conn->drop();
208c207
< 	current_call_->success_ = ( ok > 0 ? true : false );
---
>     current_call_->success_ = ok;
233c232,233
<       *current_call_->resp_ = SerializedMessage(buffer, size);
---
>       current_call_->resp_->__serialized_length = size;
>       current_call_->resp_->deserialize(buffer.get());
296c296
<       connection_->drop(Connection::Destructing);
---
>       connection_->drop();
305c305,306
<     SerializedMessage request;
---
>     boost::shared_array<uint8_t> dummy;
>     SerializedMessage request(dummy, 0);
309c310,315
<       request = current_call_->req_;
---
> 
>       uint32_t num_bytes = current_call_->req_->serializationLength() + 4;
> 
>       request = SerializedMessage(boost::shared_array<uint8_t>(new uint8_t[num_bytes]), num_bytes);
>       *((uint32_t*)request.buf.get()) = num_bytes - 4;
>       current_call_->req_->serialize(request.buf.get() + 4, 0);
316c322
< bool ServiceServerLink::call(const SerializedMessage& req, SerializedMessage& resp)
---
> bool ServiceServerLink::call(Message* req, Message* resp)
320c326
<   info->resp_ = &resp;
---
>   info->resp_ = resp;
326,327d331
<   //ros::WallDuration(0.1).sleep();
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/single_subscriber_publisher.cpp tmp/old/core/roscpp/src/libros/single_subscriber_publisher.cpp
42c42
< void SingleSubscriberPublisher::publish(const SerializedMessage& m) const
---
> void SingleSubscriberPublisher::publish(const MessageConstPtr& message) const
44c44,49
<   link_->enqueueMessage(m, true, true);
---
>   link_->publish(*message);
> }
> 
> void SingleSubscriberPublisher::publish(const Message& message) const
> {
>   link_->publish(message);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/subscriber.cpp tmp/old/core/roscpp/src/libros/subscriber.cpp
63c63
< Subscriber::Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionCallbackHelperPtr& helper)
---
> Subscriber::Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionMessageHelperPtr& helper)
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/subscriber_link.cpp tmp/old/core/roscpp/src/libros/subscriber_link.cpp
68,85d67
< const std::string& SubscriberLink::getMD5Sum()
< {
<   PublicationPtr parent = parent_.lock();
<   return parent->getMD5Sum();
< }
< 
< const std::string& SubscriberLink::getDataType()
< {
<   PublicationPtr parent = parent_.lock();
<   return parent->getDataType();
< }
< 
< const std::string& SubscriberLink::getMessageDefinition()
< {
<   PublicationPtr parent = parent_.lock();
<   return parent->getMessageDefinition();
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/subscription.cpp tmp/old/core/roscpp/src/libros/subscription.cpp
35,40c35
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #include <Winsock2.h>
< #include <Ws2tcpip.h>
< #else
---
> #include <sstream>
43,46d37
< #include <sys/poll.h> // for POLLOUT
< #endif //WIN32
< 
< #include <sstream>
47a39
> #include <sys/poll.h> // for POLLOUT
50d41
< #include <typeinfo>
70,72d60
< #include "ros/subscription_callback_helper.h"
< 
< #include <boost/make_shared.hpp>
83d70
< , nonconst_callbacks_(0)
204c191
<   addPublisherLink(pub_link);
---
>   publisher_links_.push_back(pub_link);
208,216d194
< bool urisEqual(const std::string& uri1, const std::string& uri2)
< {
<   std::string host1, host2;
<   uint32_t port1 = 0, port2 = 0;
<   network::splitURI(uri1, host1, port1);
<   network::splitURI(uri2, host2, port2);
<   return port1 == port2 && host1 == host2;
< }
< 
270c248
<         if (urisEqual((*spc)->getPublisherXMLRPCURI(), *up_i))
---
>         if ((*spc)->getPublisherXMLRPCURI() == *up_i)
289c267
<         if (urisEqual(*up_i, (*spc)->getPublisherXMLRPCURI()))
---
>         if (*up_i == (*spc)->getPublisherXMLRPCURI())
303c281
<           if (urisEqual(*up_i, (*it)->getRemoteURI()))
---
>           if (*up_i == (*it)->getRemoteURI())
318,332d295
<   for (V_PublisherLink::iterator i = subtractions.begin(); i != subtractions.end(); ++i)
<   {
< 	const PublisherLinkPtr& link = *i;
<     if (link->getPublisherXMLRPCURI() != XMLRPCManager::instance()->getServerURI())
<     {
<       ROSCPP_LOG_DEBUG("Disconnecting from publisher [%s] of topic [%s] at [%s]",
<                         link->getCallerID().c_str(), name_.c_str(), link->getPublisherXMLRPCURI().c_str());
< 		  link->drop();
< 	  }
< 	  else
< 	  {
< 		  ROSCPP_LOG_DEBUG("Disconnect: skipping myself for topic [%s]", name_.c_str());
< 	  }
< 	}
< 
346a310,325
>   for (V_PublisherLink::iterator i = subtractions.begin();
>            i != subtractions.end(); ++i)
>   {
>     const PublisherLinkPtr& link = *i;
>     if (link->getPublisherXMLRPCURI() != XMLRPCManager::instance()->getServerURI())
>     {
>       ROSCPP_LOG_DEBUG("Disconnecting from publisher [%s] of topic [%s] at [%s]",
>                   link->getCallerID().c_str(), name_.c_str(), link->getPublisherXMLRPCURI().c_str());
>       link->drop();
>     }
>     else
>     {
>       ROSCPP_LOG_DEBUG("Disconnect: skipping myself for topic [%s]", name_.c_str());
>     }
>   }
> 
411c390
<   XmlRpc::XmlRpcClient* c = new XmlRpc::XmlRpcClient(peer_host.c_str(),
---
>   XmlRpc::XmlRpcClient* c = new XmlRpc::XmlRpcClient(peer_host.c_str(), 
421,425d399
<     if (udp_transport)
<     {
<       udp_transport->close();
<     }
< 
445,452d418
< void closeTransport(const TransportUDPPtr& trans)
< {
<   if (trans)
<   {
<     trans->close();
<   }
< }
< 
480,481c446
<   	closeTransport(udp_transport);
<   	return;
---
>     return;
487,488c452
<   	closeTransport(udp_transport);
<   	return;
---
>     return;
494,495c458
<   	closeTransport(udp_transport);
<   	return;
---
>     return;
500,501c463
<   	closeTransport(udp_transport);
<   	return;
---
>     return;
531c493
<       addPublisherLink(pub_link);
---
>       publisher_links_.push_back(pub_link);
542c504
<     if (proto.size() != 6 ||
---
>     if (proto.size() != 5 ||
546,547c508
<         proto[4].getType() != XmlRpcValue::TypeInt ||
<         proto[5].getType() != XmlRpcValue::TypeBase64)
---
>         proto[4].getType() != XmlRpcValue::TypeInt)
549,551c510,511
<       ROSCPP_LOG_DEBUG("publisher implements UDPROS, but the " \
< 	    	       "parameters aren't string,int,int,int,base64");
<       closeTransport(udp_transport);
---
>     	ROSCPP_LOG_DEBUG("publisher implements UDPROS, but the " \
>                 "parameters aren't string,int,int");
558,568d517
<     std::vector<char> header_bytes = proto[5];
<     boost::shared_array<uint8_t> buffer = boost::shared_array<uint8_t>(new uint8_t[header_bytes.size()]);
<     memcpy(buffer.get(), &header_bytes[0], header_bytes.size());
<     Header h;
<     std::string err;
<     if (!h.parse(buffer, header_bytes.size(), err))
<     {
<       ROSCPP_LOG_DEBUG("Unable to parse UDPROS connection header: %s", err.c_str());
<       closeTransport(udp_transport);
<       return;
<     }
571,577c520
<     std::string error_msg;
<     if (h.getValue("error", error_msg))
<     {
<       ROSCPP_LOG_DEBUG("Received error message in header for connection to [%s]: [%s]", xmlrpc_uri.c_str(), error_msg.c_str());
<       closeTransport(udp_transport);
<       return;
<     }
---
>     //TransportUDPPtr transport(new TransportUDP(&g_node->getPollSet()));
579,580c522,528
<     TransportPublisherLinkPtr pub_link(new TransportPublisherLink(shared_from_this(), xmlrpc_uri, transport_hints_));
<     if (pub_link->setHeader(h))
---
>     //if (udp_transport->connect(pub_host, pub_port, conn_id))
>     // Using if(1) below causes a bizarre compiler error on some OS X
>     // machines.  Creating a variable and testing it doesn't.  Presumably
>     // it's related to the conditional compilation that goes on inside
>     // ROS_ERROR.
>     int foo=1;
>     if (foo)
582a531,532
>       TransportPublisherLinkPtr pub_link(new TransportPublisherLink(shared_from_this(), xmlrpc_uri, transport_hints_));
> 
584d533
<       connection->setHeader(h);
590c539
<       addPublisherLink(pub_link);
---
>       publisher_links_.push_back(pub_link);
596,598c545
<       ROSCPP_LOG_DEBUG("Failed to connect to publisher of topic [%s] at [%s:%d]", name_.c_str(), pub_host.c_str(), pub_port);
<       closeTransport(udp_transport);
<       return;
---
>     	ROSCPP_LOG_DEBUG("Failed to connect to publisher of topic [%s] at [%s:%d]", name_.c_str(), pub_host.c_str(), pub_port);
607c554,591
< uint32_t Subscription::handleMessage(const SerializedMessage& m, bool ser, bool nocopy, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link)
---
> class SubscriptionCallback : public CallbackInterface
> {
> public:
>   SubscriptionCallback(const SubscriptionQueuePtr& queue, uint64_t id)
>   : queue_(queue)
>   , id_(id)
>   , called_(false)
>   {}
> 
>   ~SubscriptionCallback()
>   {
>     if (!called_)
>     {
>       queue_->remove(id_);
>     }
>   }
> 
>   virtual CallResult call()
>   {
>     CallResult result = queue_->call(id_);
>     called_ = true;
> 
>     return result;
>   }
> 
>   virtual bool ready()
>   {
>     return queue_->ready(id_);
>   }
> 
> private:
>   SubscriptionQueuePtr queue_;
>   uint64_t id_;
>   bool called_;
> };
> typedef boost::shared_ptr<SubscriptionCallback> SubscriptionCallbackPtr;
> 
> uint32_t Subscription::handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link)
613,618c597,598
<   // Cache the deserializers by type info.  If all the subscriptions are the same type this has the same performance as before.  If
<   // there are subscriptions with different C++ type (but same ROS message type), this now works correctly rather than passing
<   // garbage to the messages with different C++ types than the first one.
<   cached_deserializers_.clear();
< 
<   ros::Time receipt_time = ros::Time::now();
---
>   MessagePtr msg;
>   MessageDeserializerPtr deserializer;
627,629c607
<     const std::type_info* ti = &info->helper_->getTypeInfo();
< 
<     if ((nocopy && m.type_info && *ti == *m.type_info) || (ser && (!m.type_info || *ti != *m.type_info)))
---
>     if (!deserializer)
631,657c609,610
<       MessageDeserializerPtr deserializer;
< 
<       V_TypeAndDeserializer::iterator des_it = cached_deserializers_.begin();
<       V_TypeAndDeserializer::iterator des_end = cached_deserializers_.end();
<       for (; des_it != des_end; ++des_it)
<       {
<         if (*des_it->first == *ti)
<         {
<           deserializer = des_it->second;
<           break;
<         }
<       }
< 
<       if (!deserializer)
<       {
<         deserializer = boost::make_shared<MessageDeserializer>(info->helper_, m, connection_header);
<         cached_deserializers_.push_back(std::make_pair(ti, deserializer));
<       }
< 
<       bool was_full = false;
<       bool nonconst_need_copy = false;
<       if (callbacks_.size() > 1)
<       {
<         nonconst_need_copy = true;
<       }
< 
<       info->subscription_queue_->push(info->helper_, deserializer, info->has_tracked_object_, info->tracked_object_, nonconst_need_copy, receipt_time, &was_full);
---
>       deserializer.reset(new MessageDeserializer(info->helper_, buffer, num_bytes, buffer_includes_size_header, connection_header));
>     }
659,666c612,614
<       if (was_full)
<       {
<         ++drops;
<       }
<       else
<       {
<         info->callback_queue_->addCallback(info->subscription_queue_, (uint64_t)info.get());
<       }
---
>     if (info->subscription_queue_->full())
>     {
>       ++drops;
667a616,619
> 
>     uint64_t id = info->subscription_queue_->push(info->helper_, deserializer, info->has_tracked_object_, info->tracked_object_);
>     SubscriptionCallbackPtr cb(new SubscriptionCallback(info->subscription_queue_, id));
>     info->callback_queue_->addCallback(cb, (uint64_t)info.get());
671c623
<   if (link->isLatched())
---
>   if (deserializer && link->isLatched())
673,678c625
<     LatchInfo li;
<     li.connection_header = connection_header;
<     li.link = link;
<     li.message = m;
<     li.receipt_time = receipt_time;
<     latched_messages_[link] = li;
---
>     latched_messages_[link] = deserializer;
681,682d627
<   cached_deserializers_.clear();
< 
686c631
< bool Subscription::addCallback(const SubscriptionCallbackHelperPtr& helper, const std::string& md5sum, CallbackQueueInterface* queue, int32_t queue_size, const VoidConstPtr& tracked_object, bool allow_concurrent_callbacks)
---
> bool Subscription::addCallback(const SubscriptionMessageHelperPtr& helper, CallbackQueueInterface* queue, int32_t queue_size, const VoidPtr& tracked_object)
690,701c635
< 
<   // Decay to a real type as soon as we have a subscriber with a real type
<   {
<     boost::mutex::scoped_lock lock(md5sum_mutex_);
<     if (md5sum_ == "*" && md5sum != "*")
<     {
< 
<       md5sum_ = md5sum;
<     }
<   }
< 
<   if (md5sum != "*" && md5sum != this->md5sum())
---
>   if (helper->getMD5Sum() != md5sum())
712c646
<     info->subscription_queue_.reset(new SubscriptionQueue(name_, queue_size, allow_concurrent_callbacks));
---
>     info->subscription_queue_.reset(new SubscriptionQueue(name_, queue_size));
720,724d653
<     if (!helper->isConst())
<     {
<       ++nonconst_callbacks_;
<     }
< 
726d654
<     cached_deserializers_.reserve(callbacks_.size());
740c668
<           M_PublisherLinkToLatchInfo::iterator des_it = latched_messages_.find(link);
---
>           M_PublisherLinkToDeserializer::iterator des_it = latched_messages_.find(link);
743c671
<             const LatchInfo& latch_info = des_it->second;
---
>             const MessageDeserializerPtr& des = des_it->second;
745,751c673,675
<             MessageDeserializerPtr des(new MessageDeserializer(helper, latch_info.message, latch_info.connection_header));
<             bool was_full = false;
<             info->subscription_queue_->push(info->helper_, des, info->has_tracked_object_, info->tracked_object_, true, latch_info.receipt_time, &was_full);
<             if (!was_full)
<             {
<               info->callback_queue_->addCallback(info->subscription_queue_, (uint64_t)info.get());
<             }
---
>             uint64_t id = info->subscription_queue_->push(info->helper_, des, info->has_tracked_object_, info->tracked_object_);
>             SubscriptionCallbackPtr cb(new SubscriptionCallback(info->subscription_queue_, id));
>             info->callback_queue_->addCallback(cb, (uint64_t)info.get());
761c685
< void Subscription::removeCallback(const SubscriptionCallbackHelperPtr& helper)
---
> void Subscription::removeCallback(const SubscriptionMessageHelperPtr& helper)
773,778d696
< 
<       if (!helper->isConst())
<       {
<         --nonconst_callbacks_;
<       }
< 
784,797d701
< void Subscription::headerReceived(const PublisherLinkPtr& link, const Header& h)
< {
<   boost::mutex::scoped_lock lock(md5sum_mutex_);
<   if (md5sum_ == "*")
<   {
<     md5sum_ = link->getMD5Sum();
<   }
< }
< 
< void Subscription::addPublisherLink(const PublisherLinkPtr& link)
< {
<   publisher_links_.push_back(link);
< }
< 
814,836d717
< void Subscription::getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti)
< {
<   boost::mutex::scoped_lock lock(callbacks_mutex_);
<   for (V_CallbackInfo::iterator cb = callbacks_.begin();
<        cb != callbacks_.end(); ++cb)
<   {
<     const CallbackInfoPtr& info = *cb;
<     if (info->helper_->getTypeInfo() == ti)
<     {
<       nocopy = true;
<     }
<     else
<     {
<       ser = true;
<     }
< 
<     if (nocopy && ser)
<     {
<       return;
<     }
<   }
< }
< 
844d724
<   boost::mutex::scoped_lock lock(md5sum_mutex_);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/subscription_queue.cpp tmp/old/core/roscpp/src/libros/subscription_queue.cpp
31d30
< #include "ros/subscription_callback_helper.h"
36c35
< SubscriptionQueue::SubscriptionQueue(const std::string& topic, int32_t queue_size, bool allow_concurrent_callbacks)
---
> SubscriptionQueue::SubscriptionQueue(const std::string& topic, int32_t queue_size)
39a39
> , id_counter_(0)
41d40
< , allow_concurrent_callbacks_(allow_concurrent_callbacks)
49,51c48
< void SubscriptionQueue::push(const SubscriptionCallbackHelperPtr& helper, const MessageDeserializerPtr& deserializer,
<                                  bool has_tracked_object, const VoidConstWPtr& tracked_object, bool nonconst_need_copy,
<                                  ros::Time receipt_time, bool* was_full)
---
> uint64_t SubscriptionQueue::push(const SubscriptionMessageHelperPtr& helper, const MessageDeserializerPtr& deserializer, bool has_tracked_object, const VoidWPtr& tracked_object)
55,59d51
<   if (was_full)
<   {
<     *was_full = false;
<   }
< 
71,75d62
< 
<     if (was_full)
<     {
<       *was_full = true;
<     }
81a69,70
>   uint64_t count = id_counter_++;
> 
87,88c76
<   i.nonconst_need_copy = nonconst_need_copy;
<   i.receipt_time = receipt_time;
---
>   i.id = count;
90a79,105
> 
>   return count;
> }
> 
> void SubscriptionQueue::remove(uint64_t id)
> {
>   boost::mutex::scoped_lock lock(queue_mutex_);
>   if (!queue_.empty())
>   {
>     if (id < queue_.front().id)
>     {
>       return;
>     }
>   }
> 
>   L_Item::iterator it = queue_.begin();
>   L_Item::iterator end = queue_.end();
>   for (; it != end; ++it)
>   {
>     const Item& i = *it;
>     if (i.id == id)
>     {
>       queue_.erase(it);
>       --queue_size_;
>       return;
>     }
>   }
102c117
< CallbackInterface::CallResult SubscriptionQueue::call()
---
> CallbackInterface::CallResult SubscriptionQueue::call(uint64_t id)
107,109c122,123
<   boost::recursive_mutex::scoped_try_lock lock(callback_mutex_, boost::defer_lock);
< 
<   if (!allow_concurrent_callbacks_)
---
>   boost::recursive_mutex::scoped_try_lock lock(callback_mutex_);
>   if (!lock.owns_lock())
111,115c125
<     lock.try_lock();
<     if (!lock.owns_lock())
<     {
<       return CallbackInterface::TryAgain;
<     }
---
>     return CallbackInterface::TryAgain;
118c128
<   VoidConstPtr tracker;
---
>   VoidPtr tracker;
130a141,150
>     if (id < i.id)
>     {
>       return CallbackInterface::Invalid;
>     }
> 
>     if (id > i.id)
>     {
>       return CallbackInterface::TryAgain;
>     }
> 
150c170
<   VoidConstPtr msg = i.deserializer->deserialize();
---
>   MessagePtr msg = i.deserializer->deserialize();
162,164c182
<     SubscriptionCallbackHelperCallParams params;
<     params.event = MessageEvent<void const>(msg, i.deserializer->getConnectionHeader(), i.receipt_time, i.nonconst_need_copy, MessageEvent<void const>::CreateFunction());
<     i.helper->call(params);
---
>     i.helper->call(msg);
170c188
< bool SubscriptionQueue::ready()
---
> bool SubscriptionQueue::ready(uint64_t id)
172c190,196
<   return true;
---
>   boost::mutex::scoped_lock lock(queue_mutex_);
>   if (queue_.empty())
>   {
>     return true;
>   }
> 
>   return id <= queue_.front().id;
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/this_node.cpp tmp/old/core/roscpp/src/libros/this_node.cpp
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
125,127d122
< #ifdef WIN32
<     sprintf_s(buf, sizeof(buf), "_%llu", (unsigned long long)WallTime::now().toNSec());
< #else
129d123
< #endif //WIN32
132,133d125
< 
<   ros::console::setFixedFilterToken("node", g_name);
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/timer.cpp tmp/old/core/roscpp/src/libros/timer.cpp
57c57
<     VoidConstPtr tracked_object;
---
>     VoidPtr tracked_object;
88,93d87
< void Timer::Impl::setPeriod(const Duration& period)
< {
<   period_ = period;
<   TimerManager<Time, Duration, TimerEvent>::global().setPeriod(timer_handle_, period);
< }
< 
140,147d133
< void Timer::setPeriod(const Duration& period)
< {
<   if (impl_)
<   {
<     impl_->setPeriod(period);
<   }
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/topic.cpp tmp/old/core/roscpp/src/libros/topic.cpp
55c55
<     if (!timeout.isZero() && ros::Time::now() >= end)
---
>     if (!timeout.isZero() && ros::Time::now() <= end)
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/topic_manager.cpp tmp/old/core/roscpp/src/libros/topic_manager.cpp
42d41
< #include "ros/subscribe_options.h"
96c95
<   poll_manager_->addPollThreadListener(boost::bind(&TopicManager::processPublishQueues, this));
---
>   poll_manager_->addPollThreadListener(boost::bind(&TopicManager::processPublishQueue, this));
109a109
>     boost::mutex::scoped_lock lock3(publish_queue_mutex_);
148a149,150
> 
>   publish_queue_.clear();
151c153
< void TopicManager::processPublishQueues()
---
> void TopicManager::processPublishQueue()
153c155,171
<   boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_);
---
>   V_PublicationAndSerializedMessagePair queue;
>   {
>     boost::mutex::scoped_lock lock(publish_queue_mutex_);
> 
>     if (isShuttingDown())
>     {
>       return;
>     }
> 
>     queue.insert(queue.end(), publish_queue_.begin(), publish_queue_.end());
>     publish_queue_.clear();
>   }
> 
>   if (queue.empty())
>   {
>     return;
>   }
155,156c173,174
<   V_Publication::iterator it = advertised_topics_.begin();
<   V_Publication::iterator end = advertised_topics_.end();
---
>   V_PublicationAndSerializedMessagePair::iterator it = queue.begin();
>   V_PublicationAndSerializedMessagePair::iterator end = queue.end();
159,160c177,178
<     const PublicationPtr& pub = *it;
<     pub->processPublishQueue();
---
>     PublicationPtr pub = it->first;
>     pub->enqueueMessage(it->second);
195,199d212
< bool md5sumsMatch(const std::string& lhs, const std::string& rhs)
< {
<   return lhs == "*" || rhs == "*" || lhs == rhs;
< }
< 
204d216
<   bool found_topic = false;
220,221c232
<         found_topic = true;
<         if (md5sumsMatch(ops.md5sum, sub->md5sum()))
---
>         if (sub->md5sum() == ops.helper->getMD5Sum())
223a235
>           break;
225d236
<         break;
230c241
<   if (found_topic && !found)
---
>   if (found)
232,238c243
<     std::stringstream ss;
<     ss << "Tried to subscribe to a topic with the same name but different md5sum as a topic that was already subscribed [" << ops.datatype << "/" << ops.md5sum << " vs. " << sub->datatype() << "/" << sub->md5sum() << "]";
<     throw ConflictingSubscriptionException(ss.str());
<   }
<   else if (found)
<   {
<     if (!sub->addCallback(ops.helper, ops.md5sum, ops.callback_queue, ops.queue_size, ops.tracked_object, ops.allow_concurrent_callbacks))
---
>     if (!sub->addCallback(ops.helper, ops.callback_queue, ops.queue_size, ops.tracked_object))
262,278c267,268
<   if (ops.md5sum.empty())
<   {
<     throw InvalidParameterException("Subscribing to topic [" + ops.topic + "] with an empty md5sum");
<   }
< 
<   if (ops.datatype.empty())
<   {
<     throw InvalidParameterException("Subscribing to topic [" + ops.topic + "] with an empty datatype");
<   }
< 
<   if (!ops.helper)
<   {
<     throw InvalidParameterException("Subscribing to topic [" + ops.topic + "] without a callback");
<   }
< 
<   const std::string& md5sum = ops.md5sum;
<   std::string datatype = ops.datatype;
---
>   std::string md5sum = ops.helper->getMD5Sum();
>   std::string datatype = ops.helper->getDataType();
281c271
<   s->addCallback(ops.helper, ops.md5sum, ops.callback_queue, ops.queue_size, ops.tracked_object, ops.allow_concurrent_callbacks);
---
>   s->addCallback(ops.helper, ops.callback_queue, ops.queue_size, ops.tracked_object);
299,301c289
<     std::stringstream ss;
<     ss << "Advertising with * as the datatype is not allowed.  Topic [" << ops.topic << "]";
<     throw InvalidParameterException(ss.str());
---
>     ROS_WARN("Advertising on topic [%s] with datatype [*].  If you are not playing back an old bag file, this is a problem.", ops.topic.c_str());
306,323c294
<     std::stringstream ss;
<     ss << "Advertising with * as the md5sum is not allowed.  Topic [" << ops.topic << "]";
<     throw InvalidParameterException(ss.str());
<   }
< 
<   if (ops.md5sum.empty())
<   {
<     throw InvalidParameterException("Advertising on topic [" + ops.topic + "] with an empty md5sum");
<   }
< 
<   if (ops.datatype.empty())
<   {
<     throw InvalidParameterException("Advertising on topic [" + ops.topic + "] with an empty datatype");
<   }
< 
<   if (ops.message_definition.empty())
<   {
<     ROS_WARN("Advertising on topic [%s] with an empty message definition.  Some tools (e.g. rosbag) may not work correctly.", ops.topic.c_str());
---
>     ROS_WARN("Advertising on topic [%s] with md5sum [*].  If you are not playing back an old bag file, this is a problem.", ops.topic.c_str());
356c327
<     pub = PublicationPtr(new Publication(ops.topic, ops.datatype, ops.md5sum, ops.message_definition, ops.queue_size, ops.latch, ops.has_header));
---
>     pub = PublicationPtr(new Publication(ops.topic, ops.datatype, ops.md5sum, ops.message_definition, ops.queue_size, ops.latch));
380c351
<       if ((*s)->getName() == ops.topic && md5sumsMatch((*s)->md5sum(), ops.md5sum) && !(*s)->isDropped())
---
>       if ((*s)->getName() == ops.topic && (*s)->md5sum() == ops.md5sum && !(*s)->isDropped())
501d471
<   const std::string& sub_md5sum = s->md5sum();
510,511c480
<       const std::string& pub_md5sum = pub->getMD5Sum();
<       if (pub->getName() == s->getName() && md5sumsMatch(pub_md5sum, sub_md5sum) && !pub->isDropped())
---
>       if (pub->getName() == s->getName() && pub->getDataType() == s->datatype() && !pub->isDropped())
632,638d600
<       PublicationPtr pub_ptr = lookupPublication(topic);
<       if(!pub_ptr)
<       {
<       	ROSCPP_LOG_DEBUG("Unable to find advertised topic %s for UDPROS connection", topic.c_str());
<         return false;
<       }
< 
641,649d602
< 
<       M_string m;
<       std::string error_msg;
<       if (!pub_ptr->validateHeader(h, error_msg))
<       {
<         ROSCPP_LOG_DEBUG("Error validating header from [%s:%d] for topic [%s]: %s", host.c_str(), port, topic.c_str(), error_msg.c_str());
<         return false;
<       }
< 
651c604
<       int conn_id = connection_manager_->getNewConnectionID();
---
>       int conn_id = connection_manager_->getUDPServerTransport()->generateConnectionId();
661,670d613
<       m["topic"] = topic;
<       m["md5sum"] = pub_ptr->getMD5Sum();
<       m["type"] = pub_ptr->getDataType();
<       m["callerid"] = this_node::getName();
<       m["message_definition"] = pub_ptr->getMessageDefinition();
<       boost::shared_array<uint8_t> msg_def_buffer;
<       uint32_t len;
<       Header::write(m, msg_def_buffer, len);
<       XmlRpcValue v(msg_def_buffer.get(), len);
<       udpros_params[5] = v;
689c632
< void TopicManager::publish(const std::string& topic, const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m)
---
> void TopicManager::publish(const std::string &topic, const Message& m)
698,699c641,642
<   PublicationPtr p = lookupPublicationWithoutLock(topic);
<   if (p->hasSubscribers() || p->isLatching())
---
>   for (V_Publication::iterator t = advertised_topics_.begin();
>        t != advertised_topics_.end(); ++t)
701,718c644
<     ROS_DEBUG_NAMED("superdebug", "Publishing message on topic [%s] with sequence number [%d]", p->getName().c_str(), p->getSequence());
< 
<     // Determine what kinds of subscribers we're publishing to.  If they're intraprocess with the same C++ type we can
<     // do a no-copy publish.
<     bool nocopy = false;
<     bool serialize = false;
< 
<     // We can only do a no-copy publish if a shared_ptr to the message is provided, and we have type information for it
<     if (m.type_info && m.message)
<     {
<       p->getPublishTypes(serialize, nocopy, *m.type_info);
<     }
<     else
<     {
<       serialize = true;
<     }
< 
<     if (!nocopy)
---
>     if ((*t)->getName() == topic)
720,738c646,654
<       m.message.reset();
<       m.type_info = 0;
<     }
< 
<     if (serialize)
<     {
<       SerializedMessage m2 = serfunc();
<       m.buf = m2.buf;
<       m.num_bytes = m2.num_bytes;
<       m.message_start = m2.message_start;
<     }
< 
<     p->publish(m);
< 
<     // If we're not doing a serialized publish we don't need to signal the pollset.  The write()
<     // call inside signal() is actually relatively expensive when doing a nocopy publish.
<     if (serialize)
<     {
<       poll_manager_->getPollSet().signal();
---
>       if (m.__getDataType() != ((*t)->getDataType()))
>       {
>         ROS_ERROR("Topic [%s] advertised as [%s], but published as [%s]", topic.c_str(), (*t)->getDataType().c_str(), m.__getDataType().c_str());
>       }
>       else
>       {
>         publish(*t, m);
>       }
>       break;
741,744d656
<   else
<   {
<     p->incrementSequence();
<   }
747c659
< void TopicManager::incrementSequence(const std::string& topic)
---
> void TopicManager::publish(const PublicationPtr& p, const Message& m)
749,750c661,662
<   PublicationPtr pub = lookupPublication(topic);
<   if (pub)
---
>   p->incrementSequence();
>   if (p->hasSubscribers() || p->isLatching())
752,754c664,665
<     pub->incrementSequence();
<   }
< }
---
>     uint32_t msg_len = m.serializationLength();
>     boost::shared_array<uint8_t> buf = boost::shared_array<uint8_t>(new uint8_t[msg_len + 4]);
756,761c667,673
< bool TopicManager::isLatched(const std::string& topic)
< {
<   PublicationPtr pub = lookupPublication(topic);
<   if (pub)
<   {
<     return pub->isLatched();
---
>     *((uint32_t*)buf.get()) = msg_len;
>     m.serialize(buf.get() + 4, p->getSequence());
>     ROS_DEBUG_NAMED("superdebug", "Publishing message on topic [%s] with sequence number [%d] of length [%d]", p->getName().c_str(), p->getSequence(), msg_len);
> 
>     boost::mutex::scoped_lock lock(publish_queue_mutex_);
>     publish_queue_.push_back(std::make_pair(p, SerializedMessage(buf, msg_len + 4)));
>     poll_manager_->getPollSet().signal();
763,764d674
< 
<   return false;
783c693
< bool TopicManager::unsubscribe(const std::string &topic, const SubscriptionCallbackHelperPtr& helper)
---
> bool TopicManager::unsubscribe(const std::string &topic, const SubscriptionMessageHelperPtr& helper)
844,845c754,755
<   PublicationPtr p = lookupPublicationWithoutLock(topic);
<   if (p)
---
>   for (V_Publication::const_iterator t = advertised_topics_.begin();
>        t != advertised_topics_.end(); ++t)
847c757,760
<     return p->getNumSubscribers();
---
>     if ((*t)->getName() == topic)
>     {
>       return (*t)->getNumSubscribers();
>     }
871c784
<     if (!(*t)->isDropped() && (*t)->getName() == topic)
---
>     if ((*t)->getName() == topic)
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/transport/transport_tcp.cpp tmp/old/core/roscpp/src/libros/transport/transport_tcp.cpp
35,47d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #include <winsock2.h>
< #include <Ws2tcpip.h>
< #else
< #include <sys/socket.h>
< #include <netinet/tcp.h>
< #include <sys/poll.h>
< #include <arpa/inet.h>
< #include <netdb.h>
< #endif //WIN32
< 
58a46,51
> #include <sys/socket.h>
> #include <netinet/tcp.h>
> 
> #include <sys/poll.h>
> #include <arpa/inet.h>
> #include <netdb.h>
91c84
< bool TransportTCP::setNonBlocking()
---
> bool TransportTCP::initializeSocket()
92a86,87
>   ROS_ASSERT(sock_ != -1);
> 
95,104c90
< #ifdef WIN32
<     u_long non_blocking = 1; //non zero value for non blocking
< 	if(ioctlsocket( sock_, FIONBIO, &non_blocking ) != 0 )
< 	{
<       ROS_ERROR("ioctlsocket (non-blocking) to socket [%d] failed with error [%d]", sock_, WSAGetLastError());
<       close();
<       return false;
< 	}
< #else
< 	// make the socket non-blocking
---
>     // make the socket non-blocking
112,124d97
< #endif //WIN32
<   }
< 
<   return true;
< }
< 
< bool TransportTCP::initializeSocket()
< {
<   ROS_ASSERT(sock_ != -1);
< 
<   if (!setNonBlocking())
<   {
<     return false;
147d119
<     ROS_DEBUG("Adding socket [%d] to pollset", sock_);
153c125
<     //enableRead();
---
>     enableRead();
182a155,156
>     ROSCPP_LOG_DEBUG("Enabling TCP Keepalive on socket [%d]", sock_);
> 
184,186d157
< #ifdef WIN32
<     if (setsockopt(sock_, SOL_SOCKET, SO_KEEPALIVE, (char*)&val, sizeof(val)) != 0)
< #else
188d158
< #endif //WIN32
190c160
<       ROS_DEBUG("setsockopt failed to set SO_KEEPALIVE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
---
>       ROS_ERROR("setsockopt failed to set SO_KEEPALIVE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
198c168
<       ROS_DEBUG("setsockopt failed to set TCP_KEEPIDLE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
---
>       ROS_ERROR("setsockopt failed to set TCP_KEEPIDLE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
204c174
<       ROS_DEBUG("setsockopt failed to set TCP_KEEPINTVL on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
---
>       ROS_ERROR("setsockopt failed to set TCP_KEEPINTVL on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
210c180
<       ROS_DEBUG("setsockopt failed to set TCP_KEEPCNT on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
---
>       ROS_ERROR("setsockopt failed to set TCP_KEEPCNT on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
215a186,187
>     ROSCPP_LOG_DEBUG("Disabling TCP Keepalive on socket [%d]", sock_);
> 
217,219d188
< #ifdef WIN32
<     if (setsockopt(sock_, SOL_SOCKET, SO_KEEPALIVE, (char *)&val, sizeof(val)) != 0)
< #else
221d189
< #endif //WIN32
223c191
<     	ROS_DEBUG("setsockopt failed to set SO_KEEPALIVE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
---
>       ROS_ERROR("setsockopt failed to set SO_KEEPALIVE on socket [%d] [%s]", sock_, cached_remote_host_.c_str());
231,232d198
<   connected_host_ = host;
<   connected_port_ = port;
236,238d201
< #ifdef WIN32
<     ROS_ERROR("socket() failed with error [%d]", WSAGetLastError());
< #else
240d202
< #endif //WIN32
244,245d205
<   setNonBlocking();
< 
281c241
<     ROSCPP_LOG_DEBUG("Resolved publisher host [%s] to [%s] for socket [%d]", host.c_str(), inet_ntoa(sin.sin_addr), sock_);
---
>     ROSCPP_LOG_DEBUG("Resolved publisher host [%s] to [%s]", host.c_str(), inet_ntoa(sin.sin_addr));
290,306c250
<   int ret = ::connect(sock_, (sockaddr *)&sin, sizeof(sin));
< #ifdef WIN32
<   Sleep(100); //Sleep for 100ms ensuring enough time for connect() to connect
< #endif //WIN32
<   ROS_ASSERT((flags_ & SYNCHRONOUS) || ret != 0);
< #ifndef WIN32
<   if (((flags_ & SYNCHRONOUS) && ret != 0) || // synchronous, connect() should return 0
<       (!(flags_ & SYNCHRONOUS) && errno != EINPROGRESS)) // asynchronous, connect() should return -1 and errno should be EINPROGRESS
<   {
<     ROSCPP_LOG_DEBUG("Connect to tcpros publisher [%s:%d] failed with error [%d, %s]", host.c_str(), port, ret, strerror(errno));
<     close();
< 
<     return false;
<   }
< #else
<   if (((flags_ & SYNCHRONOUS) && ret != 0) || // synchronous, connect() should return 0
<       (!(flags_ & SYNCHRONOUS) && WSAGetLastError() != WSAEWOULDBLOCK)) // asynchronous, connect() should return -1 and WSAGetLastError() should return WSAEWOULDBLOCK
---
>   if (::connect(sock_, (sockaddr *)&sin, sizeof(sin)))
308c252
<     ROSCPP_LOG_DEBUG("Connect to tcpros publisher [%s:%d] failed with error [%d, %d]", host.c_str(), port, ret, WSAGetLastError());
---
>     ROSCPP_LOG_DEBUG("Connect to tcpros publisher [%s:%d] failed with error [%s]", host.c_str(), port, strerror(errno));
313d256
< #endif //WIN32
320,327c263
<   if (flags_ & SYNCHRONOUS)
<   {
<     ROSCPP_LOG_DEBUG("connect() succeeded to [%s:%d] on socket [%d]", host.c_str(), port, sock_);
<   }
<   else
<   {
<     ROSCPP_LOG_DEBUG("Async connect() in progress to [%s:%d] on socket [%d]", host.c_str(), port, sock_);
<   }
---
>   ROSCPP_LOG_DEBUG("Connect succeeded to [%s:%d] on socket [%d]", host.c_str(), port, sock_);
341,343d276
< #ifdef WIN32
<     ROS_ERROR("socket() failed with error [%d]", WSAGetLastError());
< #else
345d277
< #endif //WIn32
354,356d285
< #ifdef WIN32
<     ROS_ERROR("bind() failed with error [%d]", WSAGetLastError());
< #else
358d286
< #endif //WIN32
363,366d290
< #ifdef WIN32
<   int len = sizeof(server_address_);
<   getsockname(sock_, (sockaddr *)&server_address_, &len);
< #else
369d292
< #endif //WIN32
377,381d299
<   if (!(flags_ & SYNCHRONOUS))
<   {
<     enableRead();
<   }
< 
397a316,317
>         ROSCPP_LOG_DEBUG("TCP socket [%d] closed", sock_);
> 
405,415d324
< #ifdef WIN32
<         ::shutdown(sock_, SD_BOTH);
< 		if (::closesocket(sock_) < 0)
<         {
<           ROS_ERROR("Error closing socket [%d]: [%d]", sock_, WSAGetLastError());
<         }
<         else
<         {
<           ROSCPP_LOG_DEBUG("TCP socket [%d] closed", sock_);
<         }
< #else
421,425d329
<         else
<         {
<           ROSCPP_LOG_DEBUG("TCP socket [%d] closed", sock_);
<         }
< #endif //WIN32
458,460d361
< #ifdef WIN32
<   int num_bytes = ::recv(sock_, (char*)buffer, size, 0);
< #else
462d362
< #endif //WIN32
465,466c365
< #ifdef WIN32
< 	if (errno != EAGAIN && WSAGetLastError() != WSAEWOULDBLOCK)
---
>     if (errno != EAGAIN)
468,469c367
<       ROSCPP_LOG_DEBUG("recv() on socket [%d] failed with error [%d]", sock_, WSAGetLastError());
<       close();
---
>       ROSCPP_LOG_DEBUG("recv() failed with error [%s]", strerror(errno));
475,485d372
< #else
<     if (errno != EAGAIN && errno != EWOULDBLOCK)
<     {
<       ROSCPP_LOG_DEBUG("recv() on socket [%d] failed with error [%s]", sock_, strerror(errno));
<       close();
<     }
<     else
<     {
<       num_bytes = 0;
<     }
< #endif //WIN32
511,513d397
< #ifdef WIN32
<   int num_bytes = ::send(sock_, (char*)buffer, size, 0);
< #else
515d398
< #endif //WIN32
518,525d400
< #ifdef WIN32
< 	if(WSAGetLastError() != WSAEWOULDBLOCK)
<     {
<       ROSCPP_LOG_DEBUG("send() on socket [%d] failed with error [%d]", sock_, WSAGetLastError());
< 
<       close();
<     }
< #else
528c403
<       ROSCPP_LOG_DEBUG("send() on socket [%d] failed with error [%s]", sock_, strerror(errno));
---
>       ROSCPP_LOG_DEBUG("send() failed with error [%s]", strerror(errno));
532d406
< #endif //WIN32
562,581d435
< void TransportTCP::disableRead()
< {
<   ROS_ASSERT(!(flags_ & SYNCHRONOUS));
< 
<   {
<     boost::recursive_mutex::scoped_lock lock(close_mutex_);
< 
<     if (closed_)
<     {
<       return;
<     }
<   }
< 
<   if (expecting_read_)
<   {
<     poll_set_->delEvents(sock_, POLLIN);
<     expecting_read_ = false;
<   }
< }
< 
631c485
<     ROSCPP_LOG_DEBUG("Accepted connection on socket [%d], new socket [%d]", sock_, new_sock);
---
>     ROSCPP_LOG_DEBUG("Accepted connection on socket [%d]", new_sock);
643,645d496
< #ifdef WIN32
<     ROS_ERROR("accept() on socket [%d] failed with error [%d]", sock_, WSAGetLastError());
< #else
647d497
< #endif //WIN32
662,663c512,514
<   // Handle read events before err/hup/nval, since there may be data left on the wire
<   if ((events & POLLIN) && expecting_read_)
---
>   if((events & POLLERR) ||
>      (events & POLLHUP) ||
>      (events & POLLNVAL))
665c516,521
<     if (is_server_)
---
>     ROSCPP_LOG_DEBUG("Socket %d closed with (ERR|HUP|NVAL) events %d", sock_, events);
>     close();
>   }
>   else
>   {
>     if ((events & POLLIN) && expecting_read_)
667,670c523
<       // Should not block here, because poll() said that it's ready
<       // for reading
<       TransportTCPPtr transport = accept();
<       if (transport)
---
>       if (is_server_)
672,673c525,532
<         ROS_ASSERT(accept_cb_);
<         accept_cb_(transport);
---
>         // Should not block here, because poll() said that it's ready
>         // for reading
>         TransportTCPPtr transport = accept();
>         if (transport)
>         {
>           ROS_ASSERT(accept_cb_);
>           accept_cb_(transport);
>         }
675,678c534
<     }
<     else
<     {
<       if (read_cb_)
---
>       else
680c536,539
<         read_cb_(shared_from_this());
---
>         if (read_cb_)
>         {
>           read_cb_(shared_from_this());
>         }
683d541
<   }
685,692c543
<   if (closed_)
<   {
<     return;
<   }
< 
<   if ((events & POLLOUT) && expecting_write_)
<   {
<     if (write_cb_)
---
>     if ((events & POLLOUT) && expecting_write_)
694c545,548
<       write_cb_(shared_from_this());
---
>       if (write_cb_)
>       {
>         write_cb_(shared_from_this());
>       }
697,723d550
< 
<   if (closed_)
<   {
<     return;
<   }
< 
<   if((events & POLLERR) ||
<      (events & POLLHUP) ||
<      (events & POLLNVAL))
<   {
<     uint32_t error = -1;
<     socklen_t len = sizeof(error);
< #ifdef WIN32
<     if (getsockopt(sock_, SOL_SOCKET, SO_ERROR, (char *)&error, &len) < 0)
< #else
<     if (getsockopt(sock_, SOL_SOCKET, SO_ERROR, &error, &len) < 0)
< #endif //WIN32
<     {
<       ROSCPP_LOG_DEBUG("getsockopt failed on socket [%d]", sock_);
<     }
< #ifdef WIN32
<     ROSCPP_LOG_DEBUG("Socket %d closed with (ERR|HUP|NVAL) events %d: %d", sock_, events, WSAGetLastError());
< #else
<     ROSCPP_LOG_DEBUG("Socket %d closed with (ERR|HUP|NVAL) events %d: %s", sock_, events, strerror(error));
< #endif //WIN32
<     close();
<   }
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/transport/transport_udp.cpp tmp/old/core/roscpp/src/libros/transport/transport_udp.cpp
35,48d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #define NOMINMAX
< #include <Winsock2.h>
< #include <Ws2tcpip.h>
< #else
< #include <sys/uio.h>
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< #include <netdb.h>
< #endif //WIN32
< 
56a43,47
> #include <sys/uio.h>
> #include <sys/socket.h>
> #include <netinet/in.h>
> #include <arpa/inet.h>
> #include <netdb.h>
76d66
< , data_filled_(0)
84,86d73
<   reorder_start_ = reorder_buffer_;
<   data_buffer_ = new uint8_t[max_datagram_size_];
<   data_start_ = data_buffer_;
92,93c79
<   delete [] reorder_buffer_;
<   delete [] data_buffer_;
---
>   delete[] reorder_buffer_;
153,155d138
< #ifdef WIN32
<     ROS_ERROR("socket() failed with error [%s]", WSAGetLastError());
< #else
157d139
< #endif //WIN32
207,209d188
< #ifdef WIN32
<     ROSCPP_LOG_DEBUG("Connect to udpros host [%s:%d] failed with error [%d]", host.c_str(), port, WSAGetLastError());
< #else
211d189
< #endif //WIN32
229a208
>   gen_.seed(getpid());
235,237d213
< #ifdef WIN32
<     ROS_ERROR("socket() failed with error [%d]", WSAGetLastError());
< #else
239d214
< #endif //WIN32
248,250d222
< #ifdef WIN32
<     ROS_ERROR("bind() failed with error [%d]", WSAGetLastError());
< #else
252d223
< #endif //WIN32
277,287c248
< 	// make the socket non-blocking
< #ifdef WIN32
< 	u_long non_blocking = 1; //non zero value for non blocking
< 	if(ioctlsocket( sock_, FIONBIO, &non_blocking ) != 0 )
< 	{
< 	  ROS_ERROR("ioctlsocket (non-blocking) to socket [%d] failed with error [%d]", sock_, WSAGetLastError());
< 
<       close();
<       return false;
< 	}
< #else
---
>     // make the socket non-blocking
295d255
< #endif //WIN32
329,331d288
< #ifdef WIN32
< 		if(::closesocket(sock_) < 0 )
< #else
333d289
< #endif //WIN32
335,337d290
< #ifdef WIN32
<           ROS_ERROR("Error closing socket [%d]: [%d]", sock_, WSAGetLastError());
< #else
339d291
< #endif //WIN32
376a329,333
>     struct iovec iov[2];
>     iov[0].iov_base = &header;
>     iov[0].iov_len = sizeof(header);
>     iov[1].iov_base = buffer + bytes_read;
>     iov[1].iov_len = (size - bytes_read) > max_datagram_size_ ? max_datagram_size_ : (size - bytes_read);
378,380c335,339
< #ifdef WIN32
<     SSIZE_T num_bytes = 0;
< #else
---
>     // Don't read a partial datagram when buffer gets full
>     if (iov[1].iov_len < max_datagram_size_ && bytes_read != 0)
>       break;
> 
>     // Read a datagram with header
382,383d340
< #endif //WIN32
<     bool from_previous = false;
386,391c343
<       if (reorder_start_ != reorder_buffer_)
<       {
<         from_previous = true;
<       }
< 
<       num_bytes = std::min(size - bytes_read, reorder_bytes_);
---
>       num_bytes = reorder_bytes_ + sizeof(header);
393,395c345,346
<       memcpy(buffer + bytes_read, reorder_start_, num_bytes);
<       reorder_bytes_ -= num_bytes;
<       reorder_start_ += num_bytes;
---
>       memcpy(iov[1].iov_base, reorder_buffer_, reorder_bytes_);
>       reorder_bytes_ = 0;
399c350,354
<       if (data_filled_ == 0)
---
>       num_bytes = readv(sock_, iov, 2);
>     }
>     if (num_bytes < 0)
>     {
>       if (errno != EAGAIN)
401,473c356,358
< #ifdef WIN32
<         WSABUF iov[2];
< 		WSAOVERLAPPED RecvOverlapped = {0};
< 		DWORD RecvBytes, Flags;
< 		int rc, err;
< 		iov[0].buf = (char *)&header;
< 		iov[0].len = sizeof(header);
< 		iov[1].buf = (char *)data_buffer_;
< 		iov[1].len = max_datagram_size_ - sizeof(header);
< 		// Read a datagram with header
<         //num_bytes = readv(sock_, iov, 2);
< 		rc = WSARecv(sock_, iov, 2, &RecvBytes, &Flags, &RecvOverlapped, NULL);
< 		num_bytes = RecvBytes;
< 		if ( (rc == SOCKET_ERROR) && (WSA_IO_PENDING != (err = WSAGetLastError()))) 
< 		{
<             ROS_ERROR("WSARecv failed: %d\n", err);
<             break;
<         }
< #else
<         struct iovec iov[2];
<         iov[0].iov_base = &header;
<         iov[0].iov_len = sizeof(header);
<         iov[1].iov_base = data_buffer_;
<         iov[1].iov_len = max_datagram_size_ - sizeof(header);
< 
<         // Read a datagram with header
<         num_bytes = readv(sock_, iov, 2);
< #endif //WIN32
< 
<         if (num_bytes < 0)
<         {
< #ifdef WIN32
<           if (WSAGetLastError() == WSAEWOULDBLOCK)
< #else
<           if (errno == EAGAIN || errno == EWOULDBLOCK)
< #endif //Win32
<           {
<             num_bytes = 0;
<             break;
<           }
<           else
<           {
< #ifdef WIN32
<             ROSCPP_LOG_DEBUG("readv() failed with error [%d]", WSAGetLastError());
< #else
<             ROSCPP_LOG_DEBUG("readv() failed with error [%s]", strerror(errno));
< #endif //WIN32
<             close();
<             break;
<           }
<         }
<         else if (num_bytes == 0)
<         {
<           ROSCPP_LOG_DEBUG("Socket [%d] received 0/%d bytes, closing", sock_, size);
<           close();
<           return -1;
<         }
< #ifdef WIN32
<         else if (num_bytes < (SSIZE_T)sizeof(header))
<         {
<           ROS_ERROR("Socket [%d] received short header (%d bytes): %d", sock_, int(num_bytes), WSAGetLastError());
< #else
< 		else if (num_bytes < (ssize_t)sizeof(header))
<         {
<           ROS_ERROR("Socket [%d] received short header (%d bytes): %s", sock_, int(num_bytes), strerror(errno));
< #endif //WIN32
<           close();
<           return -1;
<         }
< 
<         num_bytes -= sizeof(header);
<         data_filled_ = num_bytes;
<         data_start_ = data_buffer_;
---
>         ROSCPP_LOG_DEBUG("readv() failed with error [%s]", strerror(errno));
>         close();
>         break;
477c362
<         from_previous = true;
---
>         num_bytes = 0;
479,485d363
< 
<       num_bytes = std::min(size - bytes_read, data_filled_);
<       // Copy from the data buffer, whether it has data left in it from a previous datagram or
<       // was just filled by readv()
<       memcpy(buffer + bytes_read, data_start_, num_bytes);
<       data_filled_ = std::max((int64_t)0, (int64_t)data_filled_ - (int64_t)size);
<       data_start_ += num_bytes;
487,489c365
< 
< 
<     if (from_previous)
---
>     else if (num_bytes == 0)
491c367,369
<       bytes_read += num_bytes;
---
>       ROSCPP_LOG_DEBUG("Socket [%d] received 0/%d bytes, closing", sock_, size);
>       close();
>       return -1;
493c371
<     else
---
>     else if (num_bytes >= ssize_t(sizeof(header)))
494a373
>       num_bytes -= sizeof(header);
501c380
<             ROS_DEBUG("Received new message [%d:%d], while still working on [%d] (block %d of %d)", header.message_id_, header.block_, current_message_id_, last_block_ + 1, total_blocks_);
---
>             ROSCPP_LOG_DEBUG("Received new message [%d:%d], while still working on [%d] (block %d of %d)", header.message_id_, header.block_, current_message_id_, last_block_ + 1, total_blocks_);
505d383
<             reorder_start_ = reorder_buffer_;
509,511d386
< 
<             data_filled_ = 0;
<             data_start_ = data_buffer_;
521c396
<             ROS_DEBUG("Message Id mismatch: %d != %d", header.message_id_, current_message_id_);
---
>             ROSCPP_LOG_DEBUG("Message Id mismatch: %d != %d", header.message_id_, current_message_id_);
526c401
<             ROS_DEBUG("Expected block %d, received %d", last_block_ + 1, header.block_);
---
>             ROSCPP_LOG_DEBUG("Expected block %d, received %d", last_block_ + 1, header.block_);
533c408
<           ROS_ERROR("Unexpected UDP header OP [%d]", header.op_);
---
>           ROSCPP_LOG_DEBUG("Unexpected UDP header OP [%d]", header.op_);
536d410
< 
538d411
< 
544a418,423
>     else
>     {
>       ROS_ERROR("Socket [%d] received short header (%d bytes), closing", sock_, int(num_bytes));
>       close();
>       return -1;
>     }
546d424
< 
564,565d441
<   const uint32_t max_payload_size = max_datagram_size_ - sizeof(TransportUDPHeader);
< 
578c454
<       header.block_ = (size + max_payload_size - 1) / max_payload_size;
---
>       header.block_ = (size + max_datagram_size_ - 1) / max_datagram_size_;
586,604d461
< 
< #ifdef WIN32
<     WSABUF iov[2];
< 	WSAOVERLAPPED SendOverlapped = {0};
< 	DWORD SendBytes;
< 	int rc, err;
< 	iov[0].buf = (char *)&header;
< 	iov[0].len = sizeof(header);
< 	iov[1].buf = (char *)(buffer + bytes_sent);
< 	iov[1].len = std::min(max_payload_size, size - bytes_sent);
< 	rc = WSASend(sock_, iov, 2, &SendBytes, 0, &SendOverlapped, NULL);
<     if ((rc == SOCKET_ERROR) &&
<        (WSA_IO_PENDING != (err = WSAGetLastError()))) 
< 	{
<             ROS_ERROR("WSASend failed: %d\n", err);
<             break;
<     }
< 	SSIZE_T num_bytes = SendBytes;
< #else
609c466
<     iov[1].iov_len = std::min(max_payload_size, size - bytes_sent);
---
>     iov[1].iov_len = (size - bytes_sent) > max_datagram_size_ ? max_datagram_size_ : (size - bytes_sent);
612d468
< #endif //WIN32
615,622d470
< #ifdef WIN32
<       if(WSAGetLastError() == WSAEWOULDBLOCK )
<       {
<         ROSCPP_LOG_DEBUG("writev() failed with error [%d]", WSAGetLastError());
<         close();
<         break;
<       }
< #else
629d476
< #endif //WIN32
635,637d481
< #ifdef WIN32
<     else if (num_bytes < SSIZE_T(sizeof(header)))
< #else
639d482
< #endif //WIN32
675,694d517
< void TransportUDP::disableRead()
< {
<   ROS_ASSERT(!(flags_ & SYNCHRONOUS));
< 
<   {
<     boost::mutex::scoped_lock lock(close_mutex_);
< 
<     if (closed_)
<     {
<       return;
<     }
<   }
< 
<   if (expecting_read_)
<   {
<     poll_set_->delEvents(sock_, POLLIN);
<     expecting_read_ = false;
<   }
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/transport_publisher_link.cpp tmp/old/core/roscpp/src/libros/transport_publisher_link.cpp
35,39d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #define NOMINMAX
< #endif //WIN32
48,52d42
< #include "ros/poll_manager.h"
< #include "ros/transport/transport_tcp.h"
< #include "ros/timer_manager.h"
< #include "ros/callback_queue.h"
< #include "ros/internal_timer_manager.h"
63,65d52
< , retry_timer_handle_(-1)
< , needs_retry_(false)
< , dropping_(false)
71,78d57
<   dropping_ = true;
< 
<   if (retry_timer_handle_ != -1)
<   {
<     getInternalTimerManager()->remove(retry_timer_handle_);
<   }
< 
<   connection_->drop(Connection::Destructing);
84c63
<   connection_->addDropListener(boost::bind(&TransportPublisherLink::onConnectionDropped, this, _1, _2));
---
>   connection_->addDropListener(boost::bind(&TransportPublisherLink::onConnectionDropped, this, _1));
87d65
<   {
89,99d66
< 
<     SubscriptionPtr parent = parent_.lock();
< 
<     M_string header;
<     header["topic"] = parent->getName();
<     header["md5sum"] = parent->md5sum();
<     header["callerid"] = this_node::getName();
<     header["type"] = parent->datatype();
<     header["tcp_nodelay"] = transport_hints_.getTCPNoDelay() ? "1" : "0";
<     connection_->writeHeader(header, boost::bind(&TransportPublisherLink::onHeaderWritten, this, _1));
<   }
101d67
<   {
103c69,78
<   }
---
> 
>   SubscriptionPtr parent = parent_.lock();
> 
>   M_string header;
>   header["topic"] = parent->getName();
>   header["md5sum"] = parent->md5sum();
>   header["callerid"] = this_node::getName();
>   header["type"] = parent->datatype();
>   header["tcp_nodelay"] = transport_hints_.getTCPNoDelay() ? "1" : "0";
>   connection_->writeHeader(header, boost::bind(&TransportPublisherLink::onHeaderWritten, this, _1));
110,116c85
<   dropping_ = true;
<   connection_->drop(Connection::Destructing);
< 
<   if (SubscriptionPtr parent = parent_.lock())
<   {
<     parent->removePublisherLink(shared_from_this());
<   }
---
>   connection_->drop();
126,127d94
<   ROS_ASSERT(conn == connection_);
< 
130d96
<     drop();
134,139d99
<   if (retry_timer_handle_ != -1)
<   {
<     getInternalTimerManager()->remove(retry_timer_handle_);
<     retry_timer_handle_ = -1;
<   }
< 
147,152d106
<   if (retry_timer_handle_ != -1)
<   {
<     getInternalTimerManager()->remove(retry_timer_handle_);
<     retry_timer_handle_ = -1;
<   }
< 
167c121
<     ROS_ERROR("a message of over a gigabyte was " \
---
>     ROS_ERROR("woah! a message of over a gigabyte was " \
170,172c124,125
<                 "synchronization is lost.");
<     drop();
<     return;
---
>                 "synchronization is lost... it's over.");
>     conn->drop();
186,188c139
<   {
<     handleMessage(SerializedMessage(buffer, size), true, false);
<   }
---
>     handleMessage(buffer, size);
196,246c147
< void TransportPublisherLink::onRetryTimer(const ros::WallTimerEvent&)
< {
<   if (dropping_)
<   {
<     return;
<   }
< 
<   if (needs_retry_ && WallTime::now() > next_retry_)
<   {
<     retry_period_ = std::min(retry_period_ * 2, WallDuration(20));
<     needs_retry_ = false;
<     SubscriptionPtr parent = parent_.lock();
<     // TODO: support retry on more than just TCP
<     // For now, since UDP does not have a heartbeat, we do not attempt to retry
<     // UDP connections since an error there likely means some invalid operation has
<     // happened.
<     if (connection_->getTransport()->getType() == std::string("TCPROS"))
<     {
<       std::string topic = parent ? parent->getName() : "unknown";
< 
<       TransportTCPPtr old_transport = boost::dynamic_pointer_cast<TransportTCP>(connection_->getTransport());
<       ROS_ASSERT(old_transport);
<       const std::string& host = old_transport->getConnectedHost();
<       int port = old_transport->getConnectedPort();
< 
<       ROSCPP_LOG_DEBUG("Retrying connection to [%s:%d] for topic [%s]", host.c_str(), port, topic.c_str());
< 
<       TransportTCPPtr transport(new TransportTCP(&PollManager::instance()->getPollSet()));
<       if (transport->connect(host, port))
<       {
<         ConnectionPtr connection(new Connection);
<         connection->initialize(transport, false, HeaderReceivedFunc());
<         initialize(connection);
< 
<         ConnectionManager::instance()->addConnection(connection);
<       }
<       else
<       {
<         ROSCPP_LOG_DEBUG("connect() failed when retrying connection to [%s:%d] for topic [%s]", host.c_str(), port, topic.c_str());
<       }
<     }
<     else if (parent)
<     {
<       parent->removePublisherLink(shared_from_this());
<     }
<   }
< }
< 
< CallbackQueuePtr getInternalCallbackQueue();
< 
< void TransportPublisherLink::onConnectionDropped(const ConnectionPtr& conn, Connection::DropReason reason)
---
> void TransportPublisherLink::onConnectionDropped(const ConnectionPtr& conn)
248,252d148
<   if (dropping_)
<   {
<     return;
<   }
< 
255,257c151
<   SubscriptionPtr parent = parent_.lock();
< 
<   if (reason == Connection::TransportDisconnect)
---
>   if (SubscriptionPtr parent = parent_.lock())
259,261c153
<     std::string topic = parent ? parent->getName() : "unknown";
< 
<     ROSCPP_LOG_DEBUG("Connection to publisher [%s] to topic [%s] dropped", connection_->getTransport()->getTransportInfo().c_str(), topic.c_str());
---
>     ROSCPP_LOG_DEBUG("Connection to publisher [%s] to topic [%s] dropped", connection_->getTransport()->getTransportInfo().c_str(), parent->getName().c_str());
263,282c155
<     ROS_ASSERT(!needs_retry_);
<     needs_retry_ = true;
<     next_retry_ = WallTime::now() + retry_period_;
< 
<     if (retry_timer_handle_ == -1)
<     {
<       retry_period_ = WallDuration(0.1);
<       next_retry_ = WallTime::now() + retry_period_;
<       retry_timer_handle_ = getInternalTimerManager()->add(WallDuration(retry_period_),
<           boost::bind(&TransportPublisherLink::onRetryTimer, this, _1), getInternalCallbackQueue().get(),
<           VoidConstPtr(), false);
<     }
<     else
<     {
<       getInternalTimerManager()->setPeriod(retry_timer_handle_, retry_period_);
<     }
<   }
<   else
<   {
<     drop();
---
>     parent->removePublisherLink(shared_from_this());
286c159
< void TransportPublisherLink::handleMessage(const SerializedMessage& m, bool ser, bool nocopy)
---
> void TransportPublisherLink::handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes)
288c161
<   stats_.bytes_received_ += m.num_bytes;
---
>   stats_.bytes_received_ += num_bytes;
295c168
<     stats_.drops_ += parent->handleMessage(m, ser, nocopy, getConnection()->getHeader().getValues(), shared_from_this());
---
>     stats_.drops_ += parent->handleMessage(buffer, num_bytes, false, getConnection()->getHeader().getValues(), shared_from_this());
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/transport_subscriber_link.cpp tmp/old/core/roscpp/src/libros/transport_subscriber_link.cpp
54c54
<   drop();
---
> 
60c60
<   dropped_conn_ = connection_->addDropListener(boost::bind(&TransportSubscriberLink::onConnectionDropped, this, _1));
---
>   connection_->addDropListener(boost::bind(&TransportSubscriberLink::onConnectionDropped, this, _1));
67,68c67,70
<   std::string topic;
<   if (!header.getValue("topic", topic))
---
>   std::string md5sum, topic, client_callerid;
>   if (!header.getValue("md5sum", md5sum)
>    || !header.getValue("topic", topic)
>    || !header.getValue("callerid", client_callerid))
70c72
<     std::string msg("Header from subscriber did not have the required element: topic");
---
>     std::string msg("Header from subscriber did not have the required elements: md5sum, topic, callerid");
78,80c80
<   // This will get validated by validateHeader below
<   std::string client_callerid;
<   header.getValue("callerid", client_callerid);
---
>   ROSCPP_LOG_DEBUG("Client [%s] wants topic [%s] with md5sum [%s]", client_callerid.c_str(), topic.c_str(), md5sum.c_str());
93,94c93,94
<   std::string error_msg;
<   if (!pt->validateHeader(header, error_msg))
---
>   if (pt->getMD5Sum() != md5sum &&
>       (md5sum != std::string("*") && pt->getMD5Sum() != std::string("*")))
96,97c96,105
<     ROSCPP_LOG_DEBUG("%s", error_msg.c_str());
<     connection_->sendHeaderError(error_msg);
---
>     std::string datatype;
>     header.getValue("type", datatype);
> 
>     std::string msg = std::string("Client [") + client_callerid + std::string("] wants topic ") + topic +
>                       std::string(" to have datatype/md5sum [") + datatype + "/" + md5sum +
>                       std::string("], but our version has [") + pt->getDataType() + "/" + pt->getMD5Sum() +
>                       std::string("]. Dropping connection.");
> 
>     ROS_ERROR("%s", msg.c_str());
>     connection_->sendHeaderError(msg);
102,114c110,117
<   destination_caller_id_ = client_callerid;
<   connection_id_ = ConnectionManager::instance()->getNewConnectionID();
<   topic_ = pt->getName();
<   parent_ = PublicationWPtr(pt);
< 
<   // Send back a success, with info
<   M_string m;
<   m["type"] = pt->getDataType();
<   m["md5sum"] = pt->getMD5Sum();
<   m["message_definition"] = pt->getMessageDefinition();
<   m["callerid"] = this_node::getName();
<   m["latching"] = pt->isLatching() ? "1" : "0";
<   connection_->writeHeader(m, boost::bind(&TransportSubscriberLink::onHeaderWritten, this, _1));
---
>   // Check whether the topic (pt here) has been deleted from
>   // advertised_topics through a call to unadvertise(), which could
>   // have happened while we were waiting for the subscriber to
>   // provide the md5sum.
>   if(pt->isDropped())
>   {
>     std::string msg = std::string("received a tcpros connection for a nonexistent topic [") +
>                 topic + std::string("] from [" + connection_->getTransport()->getTransportInfo() + "] [" + client_callerid +"].");
116c119,141
<   pt->addSubscriberLink(shared_from_this());
---
>     ROS_ERROR("%s", msg.c_str());
>     connection_->sendHeaderError(msg);
> 
>     return false;
>   }
>   else
>   {
>     destination_caller_id_ = client_callerid;
>     connection_id_ = ConnectionManager::instance()->getNewConnectionID();
>     topic_ = pt->getName();
>     parent_ = PublicationWPtr(pt);
> 
>     // Send back a success, with info
>     M_string m;
>     m["type"] = pt->getDataType();
>     m["md5sum"] = pt->getMD5Sum();
>     m["message_definition"] = pt->getMessageDefinition();
>     m["callerid"] = this_node::getName();
>     m["latching"] = pt->isLatching() ? "1" : "0";
>     connection_->writeHeader(m, boost::bind(&TransportSubscriberLink::onHeaderWritten, this, _1));
> 
>     pt->addSubscriberLink(shared_from_this());
>   }
150c175
<   SerializedMessage m(dummy, (uint32_t)0);
---
>   SerializedMessage m(dummy, (unsigned int)0);
173c198
< void TransportSubscriberLink::enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy)
---
> bool TransportSubscriberLink::publish(const Message& m)
175c200
<   if (!ser)
---
>   if (!verifyDatatype(m.__getDataType()))
177c202
<     return;
---
>     return false;
179a205,222
>   uint32_t msg_len = m.serializationLength();
>   boost::shared_array<uint8_t> buf = boost::shared_array<uint8_t>(new uint8_t[msg_len + 4]);
>   *((uint32_t*)buf.get()) = msg_len;
> 
>   int seq = 0;
>   if (PublicationPtr parent = parent_.lock())
>   {
>     seq = parent->getSequence();
>   }
> 
>   m.serialize(buf.get() + 4, seq);
>   enqueueMessage(SerializedMessage(buf, msg_len + 4));
> 
>   return true;
> }
> 
> void TransportSubscriberLink::enqueueMessage(const SerializedMessage& m)
> {
225,234c268
<   // Only drop the connection if it's not already sending a header error
<   // If it is, it will automatically drop itself
<   if (connection_->isSendingHeaderError())
<   {
<     connection_->removeDropListener(dropped_conn_);
<   }
<   else
<   {
<     connection_->drop(Connection::Destructing);
<   }
---
>   connection_->drop();
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/wall_timer.cpp tmp/old/core/roscpp/src/libros/wall_timer.cpp
52c52
<     VoidConstPtr tracked_object;
---
>     VoidPtr tracked_object;
87,93d86
< void WallTimer::Impl::setPeriod(const WallDuration& period)
< {
<   period_ = period;
<   TimerManager<WallTime, WallDuration, WallTimerEvent>::global().setPeriod(timer_handle_, period);
< }
< 
< 
140,147d132
< void WallTimer::setPeriod(const WallDuration& period)
< {
<   if (impl_)
<   {
<     impl_->setPeriod(period);
<   }
< }
< 
diff -r -x .svn tmp/msvc/core/roscpp/src/libros/xmlrpc_manager.cpp tmp/old/core/roscpp/src/libros/xmlrpc_manager.cpp
28,32d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
< #ifdef WIN32
< #include <process.h>
< #endif //WIN32
96,98d90
< #ifdef WIN32
<   result = xmlrpc::responseInt(1, "", (int)_getpid());
< #else
100d91
< #endif //WIN32
Only in tmp/msvc/core/roscpp/src: roscpp
Only in tmp/msvc/core/roscpp/srv: Empty.srv
Only in tmp/msvc/core/roscpp/: srv_gen
diff -r -x .svn tmp/msvc/core/roscpp/test/CMakeLists.txt tmp/old/core/roscpp/test/CMakeLists.txt
13c13
< rosbuild_add_gtest(test/test_subscription_queue test_subscription_queue.cpp)
---
> rosbuild_add_gtest(test/test_subscription_queue subscription_queue.cpp)
16,18d15
< rosbuild_add_gtest(test/test_callback_queue test_callback_queue.cpp)
< target_link_libraries(test/test_callback_queue ros)
< 
Only in tmp/old/core/roscpp/test: subscription_queue.cpp
diff -r -x .svn tmp/msvc/core/roscpp/test/test_args.cpp tmp/old/core/roscpp/test/test_args.cpp
33c33
<  * Test removing ROS args
---
>  * Test Header serialization/deserialization
Only in tmp/msvc/core/roscpp/test: test_callback_queue.cpp
Only in tmp/msvc/core/roscpp/test: test_subscription_queue.cpp
diff -r -x .svn tmp/msvc/core/roscpp/test/test_transport_tcp.cpp tmp/old/core/roscpp/test/test_transport_tcp.cpp
85,88c85
<       if (transports_[i])
<       {
<         transports_[i]->close();
<       }
---
>       transports_[i]->close();
287,289d283
< 
<     transports_[1]->enableRead();
<     transports_[2]->enableRead();
