diff -r -x .svn tmp/msvc/core/roscpp/include/ros/advertise_options.h tmp/old/core/roscpp/include/ros/advertise_options.h
32d31
< #include "ros/message_traits.h"
70d68
<   , has_header(false)
91,94c89,91
<     md5sum = message_traits::md5sum<M>();
<     datatype = message_traits::datatype<M>();
<     message_definition = message_traits::definition<M>();
<     has_header = message_traits::hasHeader<M>();
---
>     md5sum = M::__s_getMD5Sum();
>     datatype = M::__s_getDataType();
>     message_definition = M::__s_getMessageDefinition();
119c116
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
127,132d123
<   /** \brief Tells whether or not the message has a header.  If it does, the sequence number will be written directly into the
<    *         serialized bytes after the message has been serialized.
<    */
<   bool has_header;
< 
< 
150c141
<                           const VoidConstPtr& tracked_object,
---
>                           const VoidPtr& tracked_object,
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/advertise_service_options.h tmp/old/core/roscpp/include/ros/advertise_service_options.h
32,34c32
< #include "ros/service_callback_helper.h"
< #include "ros/service_traits.h"
< #include "ros/message_traits.h"
---
> #include "ros/service_message_helper.h"
49a48,62
>    * \brief Constructor
>    * \param _service Service name to advertise on
>    * \param _helper Helper object used for creating messages and calling callbacks
>    */
>   AdvertiseServiceOptions(const std::string& _service, const ServiceMessageHelperPtr& _helper)
>   : service(_service)
>   , md5sum(_helper->getMD5Sum())
>   , datatype(_helper->getDataType())
>   , req_datatype(_helper->getRequestDataType())
>   , res_datatype(_helper->getResponseDataType())
>   , helper(_helper)
>   , callback_queue(0)
>   {}
> 
>   /**
57,59c70
<     namespace st = service_traits;
<     namespace mt = message_traits;
<     if (st::md5sum<MReq>() != st::md5sum<MRes>())
---
>     if (MReq::__s_getServerMD5Sum() != MRes::__s_getServerMD5Sum())
61c72
<       ROS_FATAL("the request and response parameters to the server "
---
>       ROS_FATAL("woah! the request and response parameters to the server "
70,74c81,85
<     md5sum = st::md5sum<MReq>();
<     datatype = st::datatype<MReq>();
<     req_datatype = mt::datatype<MReq>();
<     res_datatype = mt::datatype<MRes>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<ServiceSpec<MReq, MRes> >(_callback));
---
>     md5sum = MReq::__s_getServerMD5Sum();
>     datatype = MReq::__s_getServiceDataType();
>     req_datatype = MReq::__s_getDataType();
>     res_datatype = MRes::__s_getDataType();
>     helper = ServiceMessageHelperPtr(new ServiceMessageHelperT<MReq, MRes>(_callback));
85,86d95
<     namespace st = service_traits;
<     namespace mt = message_traits;
90,114c99,103
<     md5sum = st::md5sum<Service>();
<     datatype = st::datatype<Service>();
<     req_datatype = mt::datatype<Request>();
<     res_datatype = mt::datatype<Response>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<ServiceSpec<Request, Response> >(_callback));
<   }
< 
<   /**
<    * \brief Templated convenience method for filling out md5sum/etc. based on the service spec type
<    * \param _service Service name to advertise on
<    * \param _callback Callback to call when this service is called
<    */
<   template<class Spec>
<   void initBySpecType(const std::string& _service, const typename Spec::CallbackType& _callback)
<   {
<     namespace st = service_traits;
<     namespace mt = message_traits;
<     typedef typename Spec::RequestType Request;
<     typedef typename Spec::ResponseType Response;
<     service = _service;
<     md5sum = st::md5sum<Request>();
<     datatype = st::datatype<Request>();
<     req_datatype = mt::datatype<Request>();
<     res_datatype = mt::datatype<Response>();
<     helper = ServiceCallbackHelperPtr(new ServiceCallbackHelperT<Spec>(_callback));
---
>     md5sum = Service::getMD5Sum();
>     datatype = Service::getDataType();
>     req_datatype = Request::__s_getDataType();
>     res_datatype = Request::__s_getDataType();
>     helper = ServiceMessageHelperPtr(new ServiceMessageHelperT<Request, Response>(_callback));
123c112
<   ServiceCallbackHelperPtr helper;                                     ///< Helper object used for creating messages and calling callbacks
---
>   ServiceMessageHelperPtr helper;                                     ///< Helper object used for creating messages and calling callbacks
137c126
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
149c138
<                                  const VoidConstPtr& tracked_object,
---
>                                  const VoidPtr& tracked_object,
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/callback_queue.h tmp/old/core/roscpp/include/ros/callback_queue.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
50,52d47
< #include <deque>
< 
< #include "ros/defines.h"
60c55
< class ROS_EXPORT CallbackQueue : public CallbackQueueInterface
---
> class CallbackQueue : public CallbackQueueInterface
69,76d63
<   enum CallOneResult
<   {
<     Called,
<     TryAgain,
<     Disabled,
<     Empty,
<   };
< 
81c68
<   CallOneResult callOne()
---
>   void callOne()
83c70
<     return callOne(ros::WallDuration());
---
>     callOne(ros::WallDuration());
94c81
<   CallOneResult callOne(ros::WallDuration timeout);
---
>   void callOne(ros::WallDuration timeout);
141,143d127
<   struct TLS;
<   CallOneResult callOneCB(TLS* tls);
< 
165,167c149
<   typedef std::deque<CallbackInfo> D_CallbackInfo;
<   D_CallbackInfo callbacks_;
<   size_t calling_;
---
>   L_CallbackInfo callbacks_;
178d159
<     , cb_it(callbacks.end())
181,182c162
<     D_CallbackInfo callbacks;
<     D_CallbackInfo::iterator cb_it;
---
>     L_CallbackInfo callbacks;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/callback_queue_interface.h tmp/old/core/roscpp/include/ros/callback_queue_interface.h
40c40
< #include "ros/types.h"
---
> #include "types.h"
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/common.h tmp/old/core/roscpp/include/ros/common.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33d30
< #ifndef WIN32
35d31
< #endif //WIN32
42d37
< #include "ros/serialized_message.h"
46,47d40
< #include "ros/defines.h"
< 
49,50c42,43
< #define ROS_VERSION_MINOR 2
< #define ROS_VERSION_PATCH 1
---
> #define ROS_VERSION_MINOR 0
> #define ROS_VERSION_PATCH 0
60c53,68
< void ROS_EXPORT disableAllSignalsInThisThread();
---
> void disableAllSignalsInThisThread();
> 
> class SerializedMessage
> {
> public:
>   boost::shared_array<uint8_t> buf;
>   size_t num_bytes;
> 
>   SerializedMessage()
>   : buf(boost::shared_array<uint8_t>())
>   , num_bytes(0)
>   {}
> 
>   SerializedMessage(boost::shared_array<uint8_t> buf, size_t num_bytes)
>   : buf(buf), num_bytes(num_bytes) { }
> };
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/connection.h tmp/old/core/roscpp/include/ros/connection.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
50,51d47
< #include "ros/defines.h"
< 
72c68
< class ROS_EXPORT Connection : public boost::enable_shared_from_this<Connection>
---
> class Connection : public boost::enable_shared_from_this<Connection>
75,81d70
<   enum DropReason
<   {
<     TransportDisconnect,
<     HeaderError,
<     Destructing,
<   };
< 
93c82
<   void drop(DropReason reason);
---
>   void drop();
101,105d89
<    * \brief Returns true if we're currently sending a header error (and will be automatically dropped when it's finished)
<    */
<   bool isSendingHeaderError() { return sending_header_error_; }
< 
<   /**
149,150c133,134
<   typedef boost::signal<void(const ConnectionPtr&, DropReason reason)> DropSignal;
<   typedef boost::function<void(const ConnectionPtr&, DropReason reason)> DropFunc;
---
>   typedef boost::signal<void(const ConnectionPtr&)> DropSignal;
>   typedef boost::function<void(const ConnectionPtr&)> DropFunc;
155d138
<   void removeDropListener(const boost::signals::connection& c);
171,176d153
<   /**
<    * \brief Set the Header associated with this connection (used with UDPROS, 
<    *        which receives the connection during XMLRPC negotiation).
<    */
<   void setHeader(const Header& header) { header_ = header; }
< 
221a199,205
>   /**
>    * If there is data available to read, we always try to read into our fixed read buffer, even if a read request
>    * has not been made.
>    */
>   uint8_t fixed_read_buffer_[READ_BUFFER_SIZE];
>   uint32_t fixed_read_filled_;
> 
265,267d248
< 
<   /// If we're sending a header error we disable most other calls
<   bool sending_header_error_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/connection_manager.h tmp/old/core/roscpp/include/ros/connection_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
31d28
< #include "connection.h"
36,37d32
< #include "ros/defines.h"
< 
65c60
<   void clear(Connection::DropReason reason);
---
>   void clear();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/exceptions.h tmp/old/core/roscpp/include/ros/exceptions.h
31c31
< #include <ros/exception.h>
---
> #include <stdexcept>
36a37,47
>  * \brief Base class for all exceptions thrown by roscpp
>  */
> class Exception : public std::runtime_error
> {
> public:
>   Exception(const std::string& what)
>   : std::runtime_error(what)
>   {}
> };
> 
> /**
59,91d69
< /**
<  * \brief Thrown when a second (third,...) subscription is attempted with conflicting
<  * arguments.
<  */
< class ConflictingSubscriptionException : public ros::Exception
< {
< public:
<   ConflictingSubscriptionException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
< 
< /**
<  * \brief Thrown when an invalid parameter is passed to a method
<  */
< class InvalidParameterException : public ros::Exception
< {
< public:
<   InvalidParameterException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
< 
< /**
<  * \brief Thrown when an invalid port is specified
<  */
< class InvalidPortException : public ros::Exception
< {
< public:
<   InvalidPortException(const std::string& msg)
<   : Exception(msg)
<   {}
< };
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/file_log.h tmp/old/core/roscpp/include/ros/file_log.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
59c55
<         ROSCONSOLE_PRINT_AT_LOCATION(__VA_ARGS__); \
---
>         ros::console::print( loc.logger_, *loc.log4cxx_level_, LOG4CXX_LOCATION, __VA_ARGS__); \
63c59
<         ros::console::print(0, logger, ros::console::levels::Debug, __FILE__, __LINE__, __ROSCONSOLE_FUNCTION__, __VA_ARGS__); \
---
>         ros::console::print(logger, ros::file_log::getDebugLevel(), LOG4CXX_LOCATION, __VA_ARGS__); \
76,77c72,73
< const ROS_EXPORT std::string& getLogFilename();
< const ROS_EXPORT std::string& getLogDirectory();
---
> const std::string& getLogFilename();
> const std::string& getLogDirectory();
79,80c75,76
< ROS_EXPORT log4cxx::LoggerPtr& getFileOnlyLogger();
< ROS_EXPORT log4cxx::LevelPtr getDebugLevel();
---
> log4cxx::LoggerPtr& getFileOnlyLogger();
> log4cxx::LevelPtr getDebugLevel();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/forwards.h tmp/old/core/roscpp/include/ros/forwards.h
42c42
< #include "roscpp_macros.h"
---
> #include "macros.h"
50,51d49
< typedef boost::shared_ptr<void const> VoidConstPtr;
< typedef boost::weak_ptr<void const> VoidConstWPtr;
109c107
<                       const VoidConstPtr& tracked_object = VoidConstPtr(),
---
>                       const VoidPtr& tracked_object = VoidPtr(),
126c124
<   VoidConstWPtr tracked_object_;
---
>   VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/header.h tmp/old/core/roscpp/include/ros/header.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
40d37
< #ifndef WIN32
42,44d38
< #endif //WIN32
< 
< #include "ros/types.h"
51,52d44
< #include "ros/defines.h"
< 
65c57
< class ROS_EXPORT Header
---
> class Header
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/init.h tmp/old/core/roscpp/include/ros/init.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43,44d40
< #include "ros/defines.h"
< 
86c82
< ROS_EXPORT void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
---
> void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
96c92
< ROS_EXPORT void init(const M_string& remappings, const std::string& name, uint32_t options = 0);
---
> void init(const M_string& remappings, const std::string& name, uint32_t options = 0);
106c102
< ROS_EXPORT void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0);
---
> void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0);
111c107
< ROS_EXPORT bool isInitialized();
---
> bool isInitialized();
115c111
< ROS_EXPORT bool isShuttingDown();
---
> bool isShuttingDown();
127c123
< ROS_EXPORT void spin();
---
> void spin();
141c137
< ROS_EXPORT void spin(Spinner& spinner);
---
> void spin(Spinner& spinner);
150c146
< ROS_EXPORT void spinOnce();
---
> void spinOnce();
155c151
< ROS_EXPORT void waitForShutdown();
---
> void waitForShutdown();
163c159
< ROS_EXPORT bool ok();
---
> bool ok();
170c166
< ROS_EXPORT void shutdown();
---
> void shutdown();
177c173
< ROS_EXPORT void requestShutdown();
---
> void requestShutdown();
187c183
< ROS_EXPORT void start();
---
> void start();
191c187
< ROS_EXPORT bool isStarted();
---
> bool isStarted();
199c195
< ROS_EXPORT CallbackQueue* getGlobalCallbackQueue();
---
> CallbackQueue* getGlobalCallbackQueue();
209c205
< ROS_EXPORT void removeROSArgs(int argc, const char* const* argv, V_string& args_out);
---
> void removeROSArgs(int argc, const char** argv, V_string& args_out);
Only in tmp/msvc/core/roscpp/include/ros/: internal_timer_manager.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/intraprocess_publisher_link.h tmp/old/core/roscpp/include/ros/intraprocess_publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,38d32
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
< 
52c46
< class ROS_EXPORT IntraProcessPublisherLink : public PublisherLink
---
> class IntraProcessPublisherLink : public PublisherLink
66,68c60
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy);
< 
<   void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes);
73d64
<   boost::recursive_mutex drop_mutex_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/intraprocess_subscriber_link.h tmp/old/core/roscpp/include/ros/intraprocess_subscriber_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,37d31
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
< 
47c41
< class ROS_EXPORT IntraProcessSubscriberLink : public SubscriberLink
---
> class IntraProcessSubscriberLink : public SubscriberLink
56c50,51
<   virtual void enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual bool publish(const Message& m);
>   virtual void enqueueMessage(const SerializedMessage& m);
59,60d53
<   virtual bool isIntraprocess() { return true; }
<   virtual void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
65d57
<   boost::recursive_mutex drop_mutex_;
Only in tmp/old/core/roscpp/include/ros/: macros.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/master.h tmp/old/core/roscpp/include/ros/master.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
57c53
< ROS_EXPORT bool execute(const std::string& method, const XmlRpc::XmlRpcValue& request, XmlRpc::XmlRpcValue& response, XmlRpc::XmlRpcValue& payload, bool wait_for_master);
---
> bool execute(const std::string& method, const XmlRpc::XmlRpcValue& request, XmlRpc::XmlRpcValue& response, XmlRpc::XmlRpcValue& payload, bool wait_for_master);
63c59
< const ROS_EXPORT std::string& getHost();
---
> const std::string& getHost();
68c64
< ROS_EXPORT uint32_t getPort();
---
> uint32_t getPort();
72c68
< const ROS_EXPORT std::string& getURI();
---
> const std::string& getURI();
83c79
< ROS_EXPORT bool check();
---
> bool check();
91c87
<   TopicInfo(const std::string& _name, const std::string& _datatype /*, const std::string& _md5sum*/)
---
>   TopicInfo(const std::string& _name, const std::string& _datatype, const std::string& _md5sum)
94c90
<   //, md5sum(_md5sum)
---
>   , md5sum(_md5sum)
98,100c94
< 
<   // not possible yet unfortunately (master does not have this information)
<   //std::string md5sum;      ///< md5sum of the topic
---
>   std::string md5sum;      ///< md5sum of the topic
116c110
< ROS_EXPORT bool getTopics(V_TopicInfo& topics);
---
> bool getTopics(V_TopicInfo& topics);
121c115
< ROS_EXPORT bool getNodes(V_string& nodes);
---
> bool getNodes(V_string& nodes);
127,133c121
< ROS_EXPORT void setRetryTimeout(ros::WallDuration timeout);
< 
< #ifdef WIN32
< ROS_EXPORT void setURI(const std::string uri);
< ROS_EXPORT void setHost(const std::string host);
< ROS_EXPORT void setPort(const uint32_t port);
< #endif //WIN32
---
> void setRetryTimeout(ros::WallDuration timeout);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/message_deserializer.h tmp/old/core/roscpp/include/ros/message_deserializer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "forwards.h"
---
> #include "subscription_message_helper.h"
35d32
< #include <ros/serialized_message.h>
40,41d36
< #include "ros/defines.h"
< 
45,48c40
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT MessageDeserializer
---
> class MessageDeserializer
51c43
<   MessageDeserializer(const SubscriptionCallbackHelperPtr& helper, const SerializedMessage& m, const boost::shared_ptr<M_string>& connection_header);
---
>   MessageDeserializer(const SubscriptionMessageHelperPtr& helper, const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header);
53,54c45
<   VoidConstPtr deserialize();
<   const boost::shared_ptr<M_string>& getConnectionHeader() { return connection_header_; }
---
>   MessagePtr deserialize();
57,58c48,51
<   SubscriptionCallbackHelperPtr helper_;
<   SerializedMessage serialized_message_;
---
>   SubscriptionMessageHelperPtr helper_;
>   boost::shared_array<uint8_t> buffer_;
>   uint32_t num_bytes_;
>   bool buffer_includes_size_header_;
62c55
<   VoidConstPtr msg_;
---
>   MessagePtr msg_;
Only in tmp/msvc/core/roscpp/include/ros/: message_event.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/message.h tmp/old/core/roscpp/include/ros/message.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "roscpp_macros.h"
---
> #include "macros.h"
39d36
< #ifndef WIN32
41d37
< #endif //WIN32
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/names.h tmp/old/core/roscpp/include/ros/names.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
49c45
< ROS_EXPORT std::string clean(const std::string& name);
---
> std::string clean(const std::string& name);
59c55
< ROS_EXPORT std::string resolve(const std::string& name, bool remap = true);
---
> std::string resolve(const std::string& name, bool remap = true);
70c66
< ROS_EXPORT std::string resolve(const std::string& ns, const std::string& name, bool remap = true);
---
> std::string resolve(const std::string& ns, const std::string& name, bool remap = true);
74c70
< ROS_EXPORT std::string append(const std::string& left, const std::string& right);
---
> std::string append(const std::string& left, const std::string& right);
79c75
< ROS_EXPORT std::string remap(const std::string& name);
---
> std::string remap(const std::string& name);
83c79
< ROS_EXPORT bool validate(const std::string& name, std::string& error);
---
> bool validate(const std::string& name, std::string& error);
85,86c81,82
< const ROS_EXPORT M_string& getRemappings();
< const ROS_EXPORT M_string& getUnresolvedRemappings();
---
> const M_string& getRemappings();
> const M_string& getUnresolvedRemappings();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/network.h tmp/old/core/roscpp/include/ros/network.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
46,51c42,43
< ROS_EXPORT bool splitURI(const std::string& uri, std::string& host, uint32_t& port);
< const ROS_EXPORT std::string& getHost();
< ROS_EXPORT uint16_t getTCPROSPort();
< #ifdef WIN32
< ROS_EXPORT void setHost( const std::string host);
< #endif //WIN32
---
> bool splitURI(const std::string& uri, std::string& host, uint32_t& port);
> const std::string& getHost();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/node_handle.h tmp/old/core/roscpp/include/ros/node_handle.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
39a38,39
> #include "ros/subscription_message_helper.h"
> #include "ros/service_message_helper.h"
53,54d52
< #include "ros/defines.h"
< 
85c83
< class ROS_EXPORT NodeHandle
---
> class NodeHandle
269c267
<                             const VoidConstPtr& tracked_object = VoidConstPtr(),
---
>                             const VoidPtr& tracked_object = VoidPtr(),
325,372d322
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Member function pointer to call when a message has arrived
<    * \param obj Object to call fp on
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class T>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for class member function with bare pointer
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using member functions, and can be used like so:
< \verbatim
< void Foo::callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< Foo foo_object;
< ros::Subscriber sub = handle.subscribe("my_topic", 1, &Foo::callback, &foo_object);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
389d338
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
419,468d367
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Member function pointer to call when a message has arrived
<    * \param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr
<    * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class T>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));
<     ops.tracked_object = obj;
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for class member function with shared_ptr
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using member functions on a shared_ptr:
< \verbatim
< void Foo::callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< boost::shared_ptr<Foo> foo_object(new Foo);
< ros::Subscriber sub = handle.subscribe("my_topic", 1, &Foo::callback, foo_object);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
486d384
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
516,561d413
<    * \param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \b not the message type, and should almost always be deduced
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param fp Function pointer to call when a message has arrived
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<M>(topic, queue_size, fp);
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
<    * \brief Subscribe to a topic, version for bare function
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, fp is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe is a convenience function for using bare functions, and can be used like so:
< \verbatim
< void callback(const std_msgs::Empty::ConstPtr& message)
< {
< }
< 
< ros::Subscriber sub = handle.subscribe("my_topic", 1, callback);
< \endverbatim
<    *
<    * \param M [template] M here is the message type
577d428
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
583c434
<     ops.template init<M>(topic, queue_size, fp);
---
>     ops.template init<M>(topic, queue_size, boost::function<void(const boost::shared_ptr<M>&)>(fp));
599d449
<    * \param M [template] M here is the message type
620d469
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
624c473
<                              const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())
---
>                              const VoidPtr& tracked_object = VoidPtr(), const TransportHints& transport_hints = TransportHints())
634,679d482
<    * \brief Subscribe to a topic, version for arbitrary boost::function object
<    *
<    * This method connects to the master to register interest in a given
<    * topic.  The node will automatically be connected with publishers on
<    * this topic.  On each message receipt, callback is invoked and passed a shared pointer
<    * to the message received.  This message should \b not be changed in place, as it
<    * is shared with any other subscriptions to this topic.
<    *
<    * This version of subscribe allows anything bindable to a boost::function object
<    *
<    * \param M [template] the message type
<    * \param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)
<    * \param topic Topic to subscribe to
<    * \param queue_size Number of incoming messages to queue up for
<    * processing (messages in excess of this queue capacity will be
<    * discarded).
<    * \param callback Callback to call when a message has arrived
<    * \param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,
<    * and if the reference count goes to 0 the subscriber callbacks will not get called.
<    * Note that setting this will cause a new reference to be added to the object before the
<    * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore
<    * thread) that the callback is invoked from.
<    * \param transport_hints a TransportHints structure which defines various transport-related options
<    * \return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.
<    * On failure, an empty Subscriber which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
<    */
<   template<class M, class C>
<   Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,
<                              const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())
<   {
<     SubscribeOptions ops;
<     ops.template initByFullCallbackType<C>(topic, queue_size, callback);
<     ops.tracked_object = tracked_object;
<     ops.transport_hints = transport_hints;
<     return subscribe(ops);
<   }
< 
<   /**
700d502
<    *  \throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype
746,783d547
<    * \brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using member functions, and can be used like so:
< \verbatim
< bool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)
< {
<   return true;
< }
< 
< Foo foo_object;
< ros::ServiceServer service = handle.advertiseService("my_service", &Foo::callback, &foo_object);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func Member function pointer to call when a message has arrived
<    * \param obj Object to call srv_func on
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    *  \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name
<    */
<   template<class T, class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));
<     return advertiseService(ops);
<   }
< 
<   /**
824,863d587
<    * \brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using member functions on shared pointers, and can be used like so:
< \verbatim
< bool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)
< {
<   return true;
< }
< 
< boost::shared_ptr<Foo> foo_object(new Foo);
< ros::ServiceServer service = handle.advertiseService("my_service", &Foo::callback, foo_object);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func Member function pointer to call when a message has arrived
<    * \param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,
<    * and if the object is deleted the service callback will stop being called (and therefore will not crash).
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class T, class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));
<     ops.tracked_object = obj;
<     return advertiseService(ops);
<   }
< 
<   /**
895,931c619
<     ops.template init<MReq, MRes>(service, srv_func);
<     return advertiseService(ops);
<   }
< 
<   /**
<    * \brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This is a convenience function for using bare functions, and can be used like so:
< \verbatim
< bool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)
< {
<   return true;
< }
< 
< ros::ServiceServer service = handle.advertiseService("my_service", callback);
< \endverbatim
<    *
<    * \param service Service name to advertise on
<    * \param srv_func function pointer to call when a message has arrived
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class MReq, class MRes>
<   ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);
---
>     ops.template init<MReq, MRes>(service, boost::function<bool(MReq&, MRes&)>(srv_func));
962c650
<   ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, const VoidConstPtr& tracked_object = VoidConstPtr())
---
>   ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, const VoidPtr& tracked_object = VoidPtr())
971,1007d658
<    * \brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type
<    *
<    * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>
<    *
<    * This call connects to the master to publicize that the node will be
<    * offering an RPC service with the given name.
<    *
<    * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything
<    * else boost::function supports).
<    *
<    * \param service Service name to advertise on
<    * \param callback Callback to call when the service is called
<    * \param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,
<    * and if the reference count goes to 0 the subscriber callbacks will not get called.
<    * Note that setting this will cause a new reference to be added to the object before the
<    * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore
<    * thread) that the callback is invoked from.
<    * \return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.
<    * On failure, an empty ServiceServer which can be checked with:
< \verbatim
< if (handle)
< {
< ...
< }
< \endverbatim
<    * \throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name
<    */
<   template<class S>
<   ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, const VoidConstPtr& tracked_object = VoidConstPtr())
<   {
<     AdvertiseServiceOptions ops;
<     ops.template initBySpecType<S>(service, callback);
<     ops.tracked_object = tracked_object;
<     return advertiseService(ops);
<   }
< 
<   /**
1095,1112d745
<   Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, bool oneshot = false) const
<   {
<     return createTimer(period, boost::bind(callback, obj, _1), oneshot);
<   }
< 
<   /**
<    * \brief Create a timer which will call a callback at the specified rate.  This variant takes
<    * a class member function, and a bare pointer to the object to call the method on.
<    *
<    * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically
<    * be stopped, and the callback will no longer be called.
<    *
<    * \param period The period at which to call the callback
<    * \param callback The method to call
<    * \param obj The object to call the method on
<    * \param oneshot If true, this timer will only fire once
<    */
<   template<class T>
1470a1104,1115
> 
>   /** \brief Get the hostname where the master runs.
>    *
>    * \return The master's hostname, as a string
>    */
>   const std::string &getMasterHost() const;
>   /** \brief Get the port where the master runs.
>    *
>    * \return The master's port.
>    */
>   int getMasterPort() const;
> 
Only in tmp/msvc/core/roscpp/include/ros/: parameter_adapter.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/param.h tmp/old/core/roscpp/include/ros/param.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
53c49
< ROS_EXPORT void set(const std::string& key, const XmlRpc::XmlRpcValue& v);
---
> void set(const std::string& key, const XmlRpc::XmlRpcValue& v);
60c56
< ROS_EXPORT void set(const std::string& key, const std::string& s);
---
> void set(const std::string& key, const std::string& s);
67c63
< ROS_EXPORT void set(const std::string& key, const char* s);
---
> void set(const std::string& key, const char* s);
74c70
< ROS_EXPORT void set(const std::string& key, double d);
---
> void set(const std::string& key, double d);
81c77
< ROS_EXPORT void set(const std::string& key, int i);
---
> void set(const std::string& key, int i);
88c84
< ROS_EXPORT void set(const std::string& key, bool b);
---
> void set(const std::string& key, bool b);
98c94
< ROS_EXPORT bool get(const std::string& key, std::string& s);
---
> bool get(const std::string& key, std::string& s);
107c103
< ROS_EXPORT bool get(const std::string& key, double& d);
---
> bool get(const std::string& key, double& d);
116c112
< ROS_EXPORT bool get(const std::string& key, int& i);
---
> bool get(const std::string& key, int& i);
125c121
< ROS_EXPORT bool get(const std::string& key, bool& b);
---
> bool get(const std::string& key, bool& b);
134c130
< ROS_EXPORT bool get(const std::string& key, XmlRpc::XmlRpcValue& v);
---
> bool get(const std::string& key, XmlRpc::XmlRpcValue& v);
149c145
< ROS_EXPORT bool getCached(const std::string& key, std::string& s);
---
> bool getCached(const std::string& key, std::string& s);
163c159
< ROS_EXPORT bool getCached(const std::string& key, double& d);
---
> bool getCached(const std::string& key, double& d);
177c173
< ROS_EXPORT bool getCached(const std::string& key, int& i);
---
> bool getCached(const std::string& key, int& i);
191c187
< ROS_EXPORT bool getCached(const std::string& key, bool& b);
---
> bool getCached(const std::string& key, bool& b);
205c201
< ROS_EXPORT bool getCached(const std::string& key, XmlRpc::XmlRpcValue& v);
---
> bool getCached(const std::string& key, XmlRpc::XmlRpcValue& v);
214c210
< ROS_EXPORT bool has(const std::string& key);
---
> bool has(const std::string& key);
222c218
< ROS_EXPORT bool del(const std::string& key);
---
> bool del(const std::string& key);
238c234
< ROS_EXPORT bool search(const std::string& ns, const std::string& key, std::string& result);
---
> bool search(const std::string& ns, const std::string& key, std::string& result);
254c250
< ROS_EXPORT bool search(const std::string& key, std::string& result);
---
> bool search(const std::string& key, std::string& result);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/poll_manager.h tmp/old/core/roscpp/include/ros/poll_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
40,41d37
< #include "ros/defines.h"
< 
50c46
< class ROS_EXPORT PollManager
---
> class PollManager
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/poll_set.h tmp/old/core/roscpp/include/ros/poll_set.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
42d39
< #ifndef WIN32
44d40
< #endif //WIN32
50,51d45
< #include "ros/defines.h"
< 
64c58
< class ROS_EXPORT PollSet
---
> class PollSet
149,152d142
<   boost::mutex just_deleted_mutex_;
<   typedef std::vector<int> V_int;
<   V_int just_deleted_;
< 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publication.h tmp/old/core/roscpp/include/ros/publication.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45,46d42
< #include "ros/defines.h"
< 
57c53
< class ROS_EXPORT Publication
---
> class Publication
65,66c61
<             bool latch,
<             bool has_header);
---
>             bool latch);
93c88
<   bool hasSubscribers();
---
>   bool hasSubscribers() { return !subscriber_links_.empty(); }
97,99c92
<   uint32_t getNumSubscribers();
< 
<   void getPublishTypes(bool& serialize, bool& nocopy, const std::type_info& ti);
---
>   int getNumSubscribers() { return (int)subscriber_links_.size(); }
122,123d114
<   bool isLatched() { return latch_; }
< 
142c133
<   uint32_t incrementSequence();
---
>   void incrementSequence() { ++seq_; }
148,152d138
<   void publish(SerializedMessage& m);
<   void processPublishQueue();
< 
<   bool validateHeader(const Header& h, std::string& error_msg);
< 
171d156
<   boost::mutex seq_mutex_;
184d168
<   bool has_header_;
186,191d169
< 
<   uint32_t intraprocess_subscriber_count_;
< 
<   typedef std::vector<SerializedMessage> V_SerializedMessage;
<   V_SerializedMessage publish_queue_;
<   boost::mutex publish_queue_mutex_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publisher.h tmp/old/core/roscpp/include/ros/publisher.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34d31
< #include "ros/common.h"
36,39d32
< #include "ros/serialization.h"
< #include <boost/bind.hpp>
< 
< #include "ros/defines.h"
52c45
< class ROS_EXPORT Publisher
---
> class Publisher
67,90c60
<   template<typename M>
<   void publish(const boost::shared_ptr<M>& message) const
<   {
<     using namespace serialization;
< 
<     if (!impl_)
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     if (!impl_->isValid())
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     SerializedMessage m;
<     m.type_info = &typeid(M);
<     m.message = message;
< 
<     publish(boost::bind(serializeMessage<M>, boost::ref(*message)), m);
<   }
< 
---
>   void publish(const Message::ConstPtr& message) const;
94,113c64
<   template<typename M>
<   void publish(const M& message) const
<   {
<     using namespace serialization;
< 
<     if (!impl_)
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     if (!impl_->isValid())
<     {
<       ROS_ASSERT_MSG(false, "Call to publish() on an invalid Publisher (topic [%s])", impl_->topic_.c_str());
<       return;
<     }
< 
<     SerializedMessage m;
<     publish(boost::bind(serializeMessage<M>, boost::ref(message)), m);
<   }
---
>   void publish(const Message& message) const;
137,141d87
<   /**
<    * \brief Returns whether or not this topic is latched
<    */
<   bool isLatched() const;
< 
162,165c108
<   void publish(const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m) const;
<   void incrementSequence() const;
< 
<   class ROS_EXPORT Impl
---
>   class Impl
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/publisher_link.h tmp/old/core/roscpp/include/ros/publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
44,45d41
< #include "ros/defines.h"
< 
60c56
< class ROS_EXPORT PublisherLink : public boost::enable_shared_from_this<PublisherLink>
---
> class PublisherLink : public boost::enable_shared_from_this<PublisherLink>
86c82
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy) = 0;
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes) = 0;
90,91d85
<   const std::string& getMD5Sum();
< 
104d97
<   std::string md5sum_;
Only in tmp/msvc/core/roscpp/include/ros/: roscpp_macros.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/rosout_appender.h tmp/old/core/roscpp/include/ros/rosout_appender.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45d42
< 
48,49d44
< #include "ros/defines.h"
< 
57c52
< class ROS_EXPORT ROSOutAppender : public log4cxx::AppenderSkeleton
---
> class ROSOutAppender : public log4cxx::AppenderSkeleton
76d70
< 
84,86c78
< #ifdef WIN32
< typedef log4cxx::helpers::ObjectPtrT<ROSOutAppender> ROSOutAppenderPtr;
< #else
---
> 
88d79
< #endif //WIN32
Only in tmp/msvc/core/roscpp/include/ros/: service_callback_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client.h tmp/old/core/roscpp/include/ros/service_client.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,38c32
< #include "ros/common.h"
< #include "ros/service_traits.h"
< #include "ros/serialization.h"
< 
< #include "ros/defines.h"
---
> #include "ros/message.h"
46c40
< class ROS_EXPORT ServiceClient
---
> class ServiceClient
61,62d54
<     namespace st = service_traits;
< 
68c60
<     if (strcmp(st::md5sum(req), st::md5sum(res)))
---
>     if (req.__getServerMD5Sum() != res.__getServerMD5Sum())
70,75c62,67
<       ROS_ERROR("The request and response parameters to the service "
<                  "call must be autogenerated from the same "
<                  "server definition file (.srv). your service call "
<                  "for %s appeared to use request/response types "
<                  "from different .srv files. (%s vs. %s)", impl_->name_.c_str(), st::md5sum(req), st::md5sum(res));
<       return false;
---
>       ROS_FATAL("woah! the request and response parameters to the server "
>                    "callback function must be autogenerated from the same "
>                    "server definition file (.srv). your service call "
>                    "for %s appeared to use request/response types "
>                    "from different .srv files.", impl_->name_.c_str());
>       ROS_BREAK();
78c70
<     return call(req, res, st::md5sum(req));
---
>     return call(req, res, req.__getServerMD5Sum());
87,88d78
<     namespace st = service_traits;
< 
94c84
<     return call(service.request, service.response, st::md5sum(service));
---
>     return call(service.request, service.response, service.getMD5Sum());
98c88
<    * \brief Mostly for internal use, the other templated versions of call() just call into this one
---
>    * \brief Mostly for internal use, the templated versions of call() just call into this one
100,125c90
<   template<typename MReq, typename MRes>
<   bool call(const MReq& req, MRes& resp, const std::string& service_md5sum)
<   {
<     namespace ser = serialization;
<     SerializedMessage ser_req = ser::serializeMessage(req);
<     SerializedMessage ser_resp;
<     bool ok = call(ser_req, ser_resp, service_md5sum);
<     if (!ok)
<     {
<       return false;
<     }
< 
<     try
<     {
<       ser::deserializeMessage(ser_resp, resp);
<     }
<     catch (std::exception& e)
<     {
<       deserializeFailed(e);
<       return false;
<     }
< 
<     return true;
<   }
< 
<   bool call(const SerializedMessage& req, SerializedMessage& resp, const std::string& service_md5sum);
---
>   bool call(Message& req, Message& resp, const std::string& service_md5sum);
179,186d143
<   // This works around a problem with the OSX linker that causes the static variable declared by
<   // ROS_ERROR to error with missing symbols when it's used directly in the templated call() method above
<   // This for some reason only showed up in the rxtools package
<   void deserializeFailed(const std::exception& e)
<   {
<     ROS_ERROR("Exception thrown while while deserializing service call: %s", e.what());
<   }
< 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client_link.h tmp/old/core/roscpp/include/ros/service_client_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
38d35
< #include <boost/signals/connection.hpp>
42,43d38
< #include "ros/defines.h"
< 
46a42,43
> class Message;
> typedef boost::shared_ptr<Message> MessagePtr;
56c53
< class ROS_EXPORT ServiceClientLink : public boost::enable_shared_from_this<ServiceClientLink>
---
> class ServiceClientLink : public boost::enable_shared_from_this<ServiceClientLink>
71c68
<   void processResponse(bool ok, const SerializedMessage& res);
---
>   void processResponse(bool ok, const MessagePtr& resp);
85,86d81
<   bool persistent_;
<   boost::signals::connection dropped_conn_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_client_options.h tmp/old/core/roscpp/include/ros/service_client_options.h
32d31
< #include "ros/service_traits.h"
72,73d70
<     namespace st = service_traits;
< 
75c72
<     md5sum = st::md5sum<MReq>();
---
>     md5sum = MReq::__s_getServerMD5Sum();
90,91d86
<     namespace st = service_traits;
< 
93c88
<     md5sum = st::md5sum<Service>();
---
>     md5sum = Service::getMD5Sum();
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service.h tmp/old/core/roscpp/include/ros/service.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
38,39d35
< #include "ros/service_traits.h"
< #include "ros/names.h"
43,44d38
< #include "ros/defines.h"
< 
71d64
<   namespace st = service_traits;
73c66
<   ServiceClientOptions ops(ros::names::resolve(service_name), st::md5sum(req), false, M_string());
---
>   ServiceClientOptions ops(service_name, req.__getServerMD5Sum(), false, M_string());
91,92d83
<   namespace st = service_traits;
< 
94c85
<   ServiceClientOptions ops(ros::names::resolve(service_name), st::md5sum(service), false, M_string());
---
>   ServiceClientOptions ops(service_name, service.getMD5Sum(), false, M_string());
106c97
< ROS_EXPORT bool waitForService(const std::string& service_name, int32_t timeout);
---
> bool waitForService(const std::string& service_name, int32_t timeout);
115c106
< ROS_EXPORT bool waitForService(const std::string& service_name, ros::Duration timeout = ros::Duration(-1));
---
> bool waitForService(const std::string& service_name, ros::Duration timeout = ros::Duration(-1));
124c115
< ROS_EXPORT bool exists(const std::string& service_name, bool print_failure_reason);
---
> bool exists(const std::string& service_name, bool print_failure_reason);
140c131
<   ServiceClient client = nh.template serviceClient<MReq, MRes>(ros::names::resolve(service_name), persistent, header_values);
---
>   ServiceClient client = nh.template serviceClient<MReq, MRes>(service_name, persistent, header_values);
158c149
<   ServiceClient client = nh.template serviceClient<Service>(ros::names::resolve(service_name), persistent, header_values);
---
>   ServiceClient client = nh.template serviceClient<Service>(service_name, persistent, header_values);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_manager.h tmp/old/core/roscpp/include/ros/service_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
39,41d36
< #include <boost/thread/recursive_mutex.hpp>
< 
< #include "ros/defines.h"
58c53
< class ROS_EXPORT ServiceManager
---
> class ServiceManager
140c135
<   boost::recursive_mutex shutting_down_mutex_;
---
>   boost::mutex shutting_down_mutex_;
Only in tmp/old/core/roscpp/include/ros/: service_message_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_publication.h tmp/old/core/roscpp/include/ros/service_publication.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33c31
< #include "ros/service_callback_helper.h"
---
> #include "ros/service_message_helper.h"
47,48d44
< #include "ros/defines.h"
< 
65c61
< class ROS_EXPORT ServicePublication : public boost::enable_shared_from_this<ServicePublication>
---
> class ServicePublication : public boost::enable_shared_from_this<ServicePublication>
69,70c65,66
<                 const std::string& response_data_type, const ServiceCallbackHelperPtr& helper, CallbackQueueInterface* queue,
<                 const VoidConstPtr& tracked_object);
---
>                 const std::string& response_data_type, const ServiceMessageHelperPtr& helper, CallbackQueueInterface* queue,
>                 const VoidPtr& tracked_object);
110c106
<   ServiceCallbackHelperPtr helper_;
---
>   ServiceMessageHelperPtr helper_;
119c115
<   VoidConstWPtr tracked_object_;
---
>   VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_server.h tmp/old/core/roscpp/include/ros/service_server.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
48c44
< class ROS_EXPORT ServiceServer
---
> class ServiceServer
88c84
<   class ROS_EXPORT Impl
---
>   class Impl
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/service_server_link.h tmp/old/core/roscpp/include/ros/service_server_link.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
49,50d46
< #include "ros/defines.h"
< 
62c58
< class ROS_EXPORT ServiceServerLink : public boost::enable_shared_from_this<ServiceServerLink>
---
> class ServiceServerLink : public boost::enable_shared_from_this<ServiceServerLink>
67,68c63,64
<     SerializedMessage req_;
<     SerializedMessage* resp_;
---
>     Message* req_;
>     Message* resp_;
110c106
<   bool call(const SerializedMessage& req, SerializedMessage& resp);
---
>   bool call(Message* req, Message* resp);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/single_subscriber_publisher.h tmp/old/core/roscpp/include/ros/single_subscriber_publisher.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35d32
< #include "ros/serialization.h"
39,40d35
< #include "ros/defines.h"
< 
47c42
< class ROS_EXPORT SingleSubscriberPublisher : public boost::noncopyable
---
> class SingleSubscriberPublisher : public boost::noncopyable
61,80c56
<   template<class M>
<   void publish(const boost::shared_ptr<M const>& message) const
<   {
<     publish(*message);
<   }
< 
<   /**
<    * \brief Publish a message on the topic associated with this Publisher.
<    *
<    * This version of publish will allow fast intra-process message-passing in the future,
<    * so you may not mutate the message after it has been passed in here (since it will be
<    * passed directly into a callback function)
<    *
<    */
<   template<class M>
<   void publish(const boost::shared_ptr<M>& message) const
<   {
<     publish(*message);
<   }
< 
---
>   void publish(const Message::ConstPtr& message) const;
84,90c60
<   template<class M>
<   void publish(const M& message) const
<   {
<     using namespace serialization;
<     SerializedMessage m = serializeMessage(message);
<     publish(m);
<   }
---
>   void publish(const Message& message) const;
103d72
<   void publish(const SerializedMessage& m) const;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/spinner.h tmp/old/core/roscpp/include/ros/spinner.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
37,38d34
< #include "ros/defines.h"
< 
61c57
< class ROS_EXPORT SingleThreadedSpinner : public Spinner
---
> class SingleThreadedSpinner : public Spinner
70c66
< class ROS_EXPORT MultiThreadedSpinner : public Spinner
---
> class MultiThreadedSpinner : public Spinner
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscribe_options.h tmp/old/core/roscpp/include/ros/subscribe_options.h
33,34c33
< #include "ros/message_traits.h"
< #include "subscription_callback_helper.h"
---
> #include "subscription_message_helper.h"
50d48
<   , allow_concurrent_callbacks(false)
60,61c58
<    * \param _md5sum
<    * \param _datatype
---
>    * \param _helper Helper object used to get create messages and call callbacks
63c60
<   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const std::string& _md5sum, const std::string& _datatype)
---
>   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const SubscriptionMessageHelperPtr& _helper)
66,67c63,65
<   , md5sum(_md5sum)
<   , datatype(_datatype)
---
>   , md5sum(_helper->getMD5Sum())
>   , datatype(_helper->getDataType())
>   , helper(_helper)
69d66
<   , allow_concurrent_callbacks(false)
73c70
<    * \brief Templated initialization, templated on callback parameter type.  Supports any callback parameters supported by the SubscriptionCallbackAdapter
---
>    * \brief Constructor
78c75,76
<    * \param _callback Callback to call when a message arrives on this topic
---
>    * \param _md5sum
>    * \param _datatype
80,91c78,84
<   template<class P>
<   void initByFullCallbackType(const std::string& _topic, uint32_t _queue_size,
<        const boost::function<void (P)>& _callback,
<        const boost::function<boost::shared_ptr<typename ParameterAdapter<P>::Message>(void)>& factory_fn = defaultMessageCreateFunction<typename ParameterAdapter<P>::Message>)
<   {
<     typedef typename ParameterAdapter<P>::Message MessageType;
<     topic = _topic;
<     queue_size = _queue_size;
<     md5sum = message_traits::md5sum<MessageType>();
<     datatype = message_traits::datatype<MessageType>();
<     helper = SubscriptionCallbackHelperPtr(new SubscriptionCallbackHelperT<P>(_callback, factory_fn));
<   }
---
>   SubscribeOptions(const std::string& _topic, uint32_t _queue_size, const std::string& _md5sum, const std::string& _datatype)
>   : topic(_topic)
>   , queue_size(_queue_size)
>   , md5sum(_md5sum)
>   , datatype(_datatype)
>   , callback_queue(0)
>   {}
94c87
<    * \brief Templated initialization, templated on message type.  Only supports "const boost::shared_ptr<M const>&" callback types
---
>    * \brief Templated initialization
103,104c96
<        const boost::function<void (const boost::shared_ptr<M const>&)>& _callback,
<        const boost::function<boost::shared_ptr<M>(void)>& factory_fn = defaultMessageCreateFunction<M>)
---
>        const boost::function<void (const boost::shared_ptr<M>&)>& _callback)
106d97
<     typedef typename ParameterAdapter<M>::Message MessageType;
109,111c100,102
<     md5sum = message_traits::md5sum<MessageType>();
<     datatype = message_traits::datatype<MessageType>();
<     helper = SubscriptionCallbackHelperPtr(new SubscriptionCallbackHelperT<const boost::shared_ptr<MessageType const>&>(_callback, factory_fn));
---
>     md5sum = M::__s_getMD5Sum();
>     datatype = M::__s_getDataType();
>     helper = SubscriptionMessageHelperPtr(new SubscriptionMessageHelperT<M>(_callback));
120c111
<   SubscriptionCallbackHelperPtr helper;                              ///< Helper object used to get create messages and call callbacks
---
>   SubscriptionMessageHelperPtr helper;                              ///< Helper object used to get create messages and call callbacks
124,127d114
<   /// By default subscription callbacks are guaranteed to arrive in-order, with only one callback happening for this subscription at any given
<   /// time.  Setting this to true allows you to receive multiple messages on the same topic from multiple threads at the same time
<   bool allow_concurrent_callbacks;
< 
138c125
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
154,155c141,142
<                                  const boost::function<void (const boost::shared_ptr<M const>&)>& callback,
<                                  const VoidConstPtr& tracked_object, CallbackQueueInterface* queue)
---
>                                  const boost::function<void (const boost::shared_ptr<M>&)>& callback,
>                                  const VoidPtr& tracked_object, CallbackQueueInterface* queue)
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscriber.h tmp/old/core/roscpp/include/ros/subscriber.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,36c32
< #include "ros/subscription_callback_helper.h"
< 
< #include "ros/defines.h"
---
> #include "ros/subscription_message_helper.h"
49c45
< class ROS_EXPORT Subscriber
---
> class Subscriber
92c88
<   Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionCallbackHelperPtr& helper);
---
>   Subscriber(const std::string& topic, const NodeHandle& node_handle, const SubscriptionMessageHelperPtr& helper);
94c90
<   class ROS_EXPORT Impl
---
>   class Impl
105c101
<     SubscriptionCallbackHelperPtr helper_;
---
>     SubscriptionMessageHelperPtr helper_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscriber_link.h tmp/old/core/roscpp/include/ros/subscriber_link.h
69a70,74
>    * \brief Publish a message directly to our subscriber.  Useful for publication connection callbacks
>    * to publish directly to the new subscriber and no-one else
>    */
>   virtual bool publish(const Message& m) = 0;
>   /**
72c77
<   virtual void enqueueMessage(const SerializedMessage& m, bool nocopy, bool ser) = 0;
---
>   virtual void enqueueMessage(const SerializedMessage& m) = 0;
78,84d82
<   virtual bool isIntraprocess() { return false; }
<   virtual void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti) { ser = true; nocopy = false; }
< 
<   const std::string& getMD5Sum();
<   const std::string& getDataType();
<   const std::string& getMessageDefinition();
< 
Only in tmp/msvc/core/roscpp/include/ros/: subscription_callback_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscription.h tmp/old/core/roscpp/include/ros/subscription.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35a34
> #include "ros/subscription_message_helper.h"
45,46d43
< #include "ros/defines.h"
< 
62,63d58
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
68c63
< class ROS_EXPORT Subscription : public boost::enable_shared_from_this<Subscription>
---
> class Subscription : public boost::enable_shared_from_this<Subscription>
102,103c97,98
<   bool addCallback(const SubscriptionCallbackHelperPtr& helper, const std::string& md5sum, CallbackQueueInterface* queue, int32_t queue_size, const VoidConstPtr& tracked_object, bool allow_concurrent_callbacks);
<   void removeCallback(const SubscriptionCallbackHelperPtr& helper);
---
>   bool addCallback(const SubscriptionMessageHelperPtr& helper, CallbackQueueInterface* queue, int32_t queue_size, const VoidPtr& tracked_object);
>   void removeCallback(const SubscriptionMessageHelperPtr& helper);
111c106
<   uint32_t handleMessage(const SerializedMessage& m, bool ser, bool nocopy, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link);
---
>   uint32_t handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes, bool buffer_includes_size_header, const boost::shared_ptr<M_string>& connection_header, const PublisherLinkPtr& link);
185,188d179
<   void getPublishTypes(bool& ser, bool& nocopy, const std::type_info& ti);
< 
<   void headerReceived(const PublisherLinkPtr& link, const Header& h);
< 
195,196d185
<   void addPublisherLink(const PublisherLinkPtr& link);
< 
202c191
<     SubscriptionCallbackHelperPtr helper_;
---
>     SubscriptionMessageHelperPtr helper_;
205c194
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
211d199
<   boost::mutex md5sum_mutex_;
216d203
<   uint32_t nonconst_callbacks_;
232,244c219,220
<   struct LatchInfo
<   {
<     SerializedMessage message;
<     PublisherLinkPtr link;
<     boost::shared_ptr<std::map<std::string, std::string> > connection_header;
<     ros::Time receipt_time;
<   };
< 
<   typedef std::map<PublisherLinkPtr, LatchInfo> M_PublisherLinkToLatchInfo;
<   M_PublisherLinkToLatchInfo latched_messages_;
< 
<   typedef std::vector<std::pair<const std::type_info*, MessageDeserializerPtr> > V_TypeAndDeserializer;
<   V_TypeAndDeserializer cached_deserializers_;
---
>   typedef std::map<PublisherLinkPtr, MessageDeserializerPtr> M_PublisherLinkToDeserializer;
>   M_PublisherLinkToDeserializer latched_messages_;
Only in tmp/old/core/roscpp/include/ros/: subscription_message_helper.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/subscription_queue.h tmp/old/core/roscpp/include/ros/subscription_queue.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35c33
< #include "message_event.h"
---
> #include "subscription_message_helper.h"
41,43c39
< #include <deque>
< 
< #include "ros/defines.h"
---
> #include <list>
51,54c47
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT SubscriptionQueue : public CallbackInterface, public boost::enable_shared_from_this<SubscriptionQueue>
---
> class SubscriptionQueue : public boost::enable_shared_from_this<SubscriptionQueue>
59c52
<     SubscriptionCallbackHelperPtr helper;
---
>     SubscriptionMessageHelperPtr helper;
63c56
<     VoidConstWPtr tracked_object;
---
>     VoidWPtr tracked_object;
65,66c58
<     bool nonconst_need_copy;
<     ros::Time receipt_time;
---
>     uint64_t id;
68c60
<   typedef std::deque<Item> D_Item;
---
>   typedef std::list<Item> L_Item;
71c63
<   SubscriptionQueue(const std::string& topic, int32_t queue_size, bool allow_concurrent_callbacks);
---
>   SubscriptionQueue(const std::string& topic, int32_t queue_size);
73c65
<   void push(const SubscriptionCallbackHelperPtr& helper, const MessageDeserializerPtr& deserializer, bool has_tracked_object, const VoidConstWPtr& tracked_object, bool nonconst_need_copy, ros::Time receipt_time = ros::Time(), bool* was_full = 0);
---
>   uint64_t push(const SubscriptionMessageHelperPtr& helper, const MessageDeserializerPtr& deserializer, bool has_tracked_object, const VoidWPtr& tracked_object);
75,77c67,68
< 
<   virtual CallbackInterface::CallResult call();
<   virtual bool ready();
---
>   CallbackInterface::CallResult call(uint64_t id);
>   bool ready(uint64_t id);
78a70
>   void remove(uint64_t id);
84a77
>   uint64_t id_counter_;
87c80
<   D_Item queue_;
---
>   L_Item queue_;
89d81
<   bool allow_concurrent_callbacks_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/this_node.h tmp/old/core/roscpp/include/ros/this_node.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
35,36d32
< #include "ros/defines.h"
< 
49c45
< const ROS_EXPORT std::string& getName();
---
> const std::string& getName();
53c49
< const ROS_EXPORT std::string& getNamespace();
---
> const std::string& getNamespace();
59c55
< ROS_EXPORT void getAdvertisedTopics(V_string& topics);
---
> void getAdvertisedTopics(V_string& topics);
65c61
< ROS_EXPORT void getSubscribedTopics(V_string& topics);
---
> void getSubscribedTopics(V_string& topics);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer.h tmp/old/core/roscpp/include/ros/timer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
49c45
< class ROS_EXPORT Timer
---
> class Timer
71,75d66
<   /**
<    * \brief Set the period of this timer
<    */
<   void setPeriod(const Duration& period);
< 
97c88
<   class ROS_EXPORT Impl
---
>   class Impl
105d95
<     void setPeriod(const Duration& period);
116c106
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer_manager.h tmp/old/core/roscpp/include/ros/timer_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45,47d42
< #include <vector>
< #include <list>
< 
60a56
>     boost::recursive_mutex callback_mutex;
72c68
<     VoidConstWPtr tracked_object;
---
>     VoidWPtr tracked_object;
75,76d70
<     // TODO: atomicize
<     boost::mutex waiting_mutex;
88,89d81
<   typedef std::list<int32_t> L_int32;
< 
94c86
<   int32_t add(const D& period, const boost::function<void(const E&)>& callback, CallbackQueueInterface* callback_queue, const VoidConstPtr& tracked_object, bool oneshot);
---
>   int32_t add(const D& period, const boost::function<void(const E&)>& callback, CallbackQueueInterface* callback_queue, const VoidPtr& tracked_object, bool oneshot);
98d89
<   void setPeriod(int32_t handle, const D& period);
109c100
<   bool waitingCompare(int32_t lhs, int32_t rhs);
---
>   bool timerCompare(const TimerInfoPtr& lhs, const TimerInfoPtr& rhs);
111,159d101
< #ifdef WIN32
<     void schedule(const TimerInfoPtr& info)
<   {
< 	  {
< 		boost::mutex::scoped_lock lock(waiting_mutex_);
< 
< 		if (info->removed)
< 		{
< 		  return;
< 		}
< 
< 		updateNext(info, T::now());
< 		waiting_.push_back(info->handle);
< 		waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
< 	  }
< 
< 	  new_timer_ = true;
< 	  timers_cond_.notify_one();
<   }
<   void updateNext(const TimerInfoPtr& info, const T& current_time)
<   {
< 	  if (info->oneshot)
< 	  {
< 		info->next_expected = T(INT_MAX, 999999999);
< 	  }
< 	  else
< 	  {
< 		// Protect against someone having called setPeriod()
< 		// If the next expected time is already past the current time
< 		// don't update it
< 		if (info->next_expected <= current_time)
< 		{
< 		  info->last_expected = info->next_expected;
< 		  info->next_expected += info->period;
< 		}
< 
< 		// detect time jumping forward, as well as callbacks that are too slow
< 		if (info->next_expected + info->period < current_time)
< 		{
< 		  //ROS_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
< 		  printf("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
< 		  info->next_expected = current_time;
< 		}
< 	  }
<   }
< #else
<   void schedule(const TimerInfoPtr& info);
<   void updateNext(const TimerInfoPtr& info, const T& current_time);
< #endif //WIN32
166,168d107
<   boost::mutex waiting_mutex_;
<   L_int32 waiting_;
< 
181,187c120,121
<     TimerQueueCallback(TimerManager<T, D, E>* parent, const TimerInfoPtr& info, T last_expected, T last_real, T current_expected)
<     : parent_(parent)
<     , info_(info)
<     , last_expected_(last_expected)
<     , last_real_(last_real)
<     , current_expected_(current_expected)
<     , called_(false)
---
>     TimerQueueCallback(const TimerInfoPtr& info, T last_expected, T last_real, T current_expected) :
>       info_(info), last_expected_(last_expected), last_real_(last_real), current_expected_(current_expected), called_(false)
189c123
<       boost::mutex::scoped_lock lock(info->waiting_mutex);
---
>       boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
198c132
<         boost::mutex::scoped_lock lock(info->waiting_mutex);
---
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
211a146,147
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
> 
215c151,156
<         VoidConstPtr tracked;
---
>         if (info->removed)
>         {
>           return Invalid;
>         }
> 
>         VoidPtr tracked;
238,239d178
< 
<         parent_->schedule(info);
246d184
<     TimerManager<T, D, E>* parent_;
274c212
< bool TimerManager<T, D, E>::waitingCompare(int32_t lhs, int32_t rhs)
---
> bool TimerManager<T, D, E>::timerCompare(const TimerInfoPtr& lhs, const TimerInfoPtr& rhs)
276,283c214
<   TimerInfoPtr infol = findTimer(lhs);
<   TimerInfoPtr infor = findTimer(rhs);
<   if (!infol || !infor)
<   {
<     return infol < infor;
<   }
< 
<   return infol->next_expected < infor->next_expected;
---
>   return lhs->next_expected < rhs->next_expected;
315c246
<     VoidConstPtr tracked = info->tracked_object.lock();
---
>     VoidPtr tracked = info->tracked_object.lock();
322d252
<   boost::mutex::scoped_lock lock2(info->waiting_mutex);
328c258
<                                    const VoidConstPtr& tracked_object, bool oneshot)
---
>                                    const VoidPtr& tracked_object, bool oneshot)
352,361c282,284
<   {
<     boost::mutex::scoped_lock lock(timers_mutex_);
<     timers_.push_back(info);
< 
<     if (!thread_started_)
<     {
<       thread_ = boost::thread(boost::bind(&TimerManager::threadFunc, this));
<       thread_started_ = true;
<     }
<   }
---
>   boost::mutex::scoped_lock lock(timers_mutex_);
>   timers_.push_back(info);
>   std::sort(timers_.begin(), timers_.end(), boost::bind(&TimerManager::timerCompare, this, _1, _2));
362a286
>   if (!thread_started_)
364,366c288,289
<     boost::mutex::scoped_lock lock(waiting_mutex_);
<     waiting_.push_back(info->handle);
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
---
>     thread_ = boost::thread(boost::bind(&TimerManager::threadFunc, this));
>     thread_started_ = true;
387,388c310,314
<       info->removed = true;
<       info->callback_queue->removeByID((uint64_t)info.get());
---
>       {
>         boost::recursive_mutex::scoped_lock lock(info->callback_mutex);
>         info->removed = true;
>         info->callback_queue->removeByID((uint64_t)info.get());
>       }
393,474d318
< 
<   {
<     boost::mutex::scoped_lock lock2(waiting_mutex_);
<     // Remove from the waiting list if it's in it
<     L_int32::iterator it = std::find(waiting_.begin(), waiting_.end(), handle);
<     if (it != waiting_.end())
<     {
<       waiting_.erase(it);
<     }
<   }
< }
< 
< #ifndef WIN32
< template<class T, class D, class E>
< void TimerManager<T, D, E>::schedule(const TimerManager<T, D, E>::TimerInfoPtr& info)
< {
<   {
<     boost::mutex::scoped_lock lock(waiting_mutex_);
< 
<     if (info->removed)
<     {
<       return;
<     }
< 
<     updateNext(info, T::now());
<     waiting_.push_back(info->handle);
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
<   }
< 
<   new_timer_ = true;
<   timers_cond_.notify_one();
< }
< 
< template<class T, class D, class E>
< void TimerManager<T, D, E>::updateNext(const TimerManager<T, D, E>::TimerInfoPtr& info, const T& current_time)
< {
<   if (info->oneshot)
<   {
<     info->next_expected = T(INT_MAX, 999999999);
<   }
<   else
<   {
<     // Protect against someone having called setPeriod()
<     // If the next expected time is already past the current time
<     // don't update it
<     if (info->next_expected <= current_time)
<     {
<       info->last_expected = info->next_expected;
<       info->next_expected += info->period;
<     }
< 
<     // detect time jumping forward, as well as callbacks that are too slow
<     if (info->next_expected + info->period < current_time)
<     {
<       ROS_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current_time - info->next_expected).toSec(), info->period.toSec(), current_time.toSec(), info->next_expected.toSec());
<       info->next_expected = current_time;
<     }
<   }
< }
< #endif //WIN32
< 
< template<class T, class D, class E>
< void TimerManager<T, D, E>::setPeriod(int32_t handle, const D& period)
< {
<   boost::mutex::scoped_lock lock(timers_mutex_);
<   TimerInfoPtr info = findTimer(handle);
< 
<   if (!info)
<   {
<     return;
<   }
< 
<   {
<     boost::mutex::scoped_lock lock(waiting_mutex_);
<     info->period = period;
<     info->next_expected = T::now() + period;
< 
<     waiting_.sort(boost::bind(&TimerManager::waitingCompare, this, _1, _2));
<   }
< 
<   new_timer_ = true;
<   timers_cond_.notify_one();
510a355,359
>     if (timers_.empty())
>     {
>       sleep_end = current + D(0.1);
>     }
>     else
512c361
<       boost::mutex::scoped_lock waitlock(waiting_mutex_);
---
>       TimerInfoPtr info = timers_.front();
514,518c363
<       if (waiting_.empty())
<       {
<         sleep_end = current + D(0.1);
<       }
<       else
---
>       while (info->next_expected <= current)
520,524c365
<         TimerInfoPtr info = findTimer(waiting_.front());
< 
<         while (!waiting_.empty() && info && info->next_expected <= current)
<         {
<           current = T::now();
---
>         current = T::now();
526,528c367,369
<           //ROS_DEBUG("Scheduling timer callback for timer [%d] of period [%f], [%f] off expected", info->handle, info->period.toSec(), (current - info->next_expected).toSec());
<           CallbackInterfacePtr cb(new TimerQueueCallback(this, info, info->last_expected, info->last_real, info->next_expected));
<           info->callback_queue->addCallback(cb, (uint64_t)info.get());
---
>         ROS_DEBUG("Scheduling timer callback for timer of period [%f]", info->period.toSec());
>         CallbackInterfacePtr cb(new TimerQueueCallback(info, info->last_expected, info->last_real, info->next_expected));
>         info->callback_queue->addCallback(cb, (uint64_t)info.get());
530c371,378
<           waiting_.pop_front();
---
>         if (info->oneshot)
>         {
>           info->next_expected = T(INT_MAX, 999999999);
>         }
>         else
>         {
>           info->last_expected = info->next_expected;
>           info->next_expected += info->period;
532c380,381
<           if (waiting_.empty())
---
>           // detect time jumping forward, as well as callbacks that are too slow
>           if (info->next_expected + info->period < current)
534c383,384
<             break;
---
>             ROSCPP_LOG_DEBUG("Time jumped forward by [%f] for timer of period [%f], resetting timer (current=%f, next_expected=%f)", (current - info->next_expected).toSec(), info->period.toSec(), current.toSec(), info->next_expected.toSec());
>             info->next_expected = current;
536,537d385
< 
<           info = findTimer(waiting_.front());
540,543c388,398
<         if (info)
<         {
<           sleep_end = info->next_expected;
<         }
---
>         std::sort(timers_.begin(), timers_.end(), boost::bind(&TimerManager::timerCompare, this, _1, _2));
>         info = timers_.front();
>       }
> 
>       if (info)
>       {
>         sleep_end = info->next_expected;
>       }
>       else
>       {
> 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/timer_options.h tmp/old/core/roscpp/include/ros/timer_options.h
72c72
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/topic.h tmp/old/core/roscpp/include/ros/topic.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43,44d40
< #include "ros/defines.h"
< 
53c49
< ROS_EXPORT void waitForMessageImpl(SubscribeOptions& ops, const boost::function<bool(void)>& ready_pred, NodeHandle& nh, ros::Duration timeout);
---
> void waitForMessageImpl(SubscribeOptions& ops, const boost::function<bool(void)>& ready_pred, NodeHandle& nh, ros::Duration timeout);
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/topic_manager.h tmp/old/core/roscpp/include/ros/topic_manager.h
33c33,34
< #include "ros/serialization.h"
---
> #include "subscribe_options.h"
> #include "advertise_options.h"
41,42d41
< #include "ros/defines.h"
< 
47,48d45
< class SubscribeOptions;
< class AdvertiseOptions;
62,65c59
< class SubscriptionCallbackHelper;
< typedef boost::shared_ptr<SubscriptionCallbackHelper> SubscriptionCallbackHelperPtr;
< 
< class ROS_EXPORT TopicManager
---
> class TopicManager
77c71
<   bool unsubscribe(const std::string &_topic, const SubscriptionCallbackHelperPtr& helper);
---
>   bool unsubscribe(const std::string &_topic, const SubscriptionMessageHelperPtr& helper);
123,132c117,134
<   template<typename M>
<   void publish(const std::string& topic, const M& message)
<   {
<     using namespace serialization;
< 
<     SerializedMessage m;
<     publish(topic, boost::bind(serializeMessage<M>, boost::ref(message)), m);
<   }
< 
<   void publish(const std::string &_topic, const boost::function<SerializedMessage(void)>& serfunc, SerializedMessage& m);
---
>   /** @brief Publish a message.
>    *
>    * This method publishes a message on a topic, delivering it to any
>    * currently connected subscribers.  If no subscribers are connected,
>    * this call does nothing.
>    *
>    * You must have already called \ref advertise()
>    * on the topic you are trying to publish to, and the type supplied in
>    * the advertise() call must match the type of the message you are trying
>    * to publish.
>    *
>    * This method can be safely called from within a subscriber connection
>    * callback.
>    *
>    * @param _topic The topic to publish to.
>    * @param msg Message to be published.
>    */
>   void publish(const std::string &_topic, const Message& m);
134,135c136
<   void incrementSequence(const std::string &_topic);
<   bool isLatched(const std::string& topic);
---
>   void publish(const PublicationPtr& p, const Message& m);
168c169
<   void processPublishQueues();
---
>   void processPublishQueue();
212a214,217
>   typedef std::vector<std::pair<PublicationPtr, SerializedMessage> > V_PublicationAndSerializedMessagePair;
>   V_PublicationAndSerializedMessagePair publish_queue_;
>   boost::mutex publish_queue_mutex_;
> 
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport.h tmp/old/core/roscpp/include/ros/transport/transport.h
85,93d84
<    * \brief Enable reading on this transport.  Allows derived classes to, for example, enable read polling for asynchronous sockets
<    */
<   virtual void enableRead() = 0;
<   /**
<    * \brief Disable reading on this transport.  Allows derived classes to, for example, disable read polling for asynchronous sockets
<    */
<   virtual void disableRead() = 0;
< 
<   /**
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport_tcp.h tmp/old/core/roscpp/include/ros/transport/transport_tcp.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
45d42
< #ifndef WIN32
47d43
< #endif //WIN32
107,109d102
<   const std::string& getConnectedHost() { return connected_host_; }
<   int getConnectedPort() { return connected_port_; }
< 
116,117d108
<   virtual void enableRead();
<   virtual void disableRead();
133,134d123
<   bool setNonBlocking();
< 
141a131,135
>   /**
>    * \brief Enables reading on our socket
>    */
>   void enableRead();
> 
160,162d153
< 
<   std::string connected_host_;
<   int connected_port_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport/transport_udp.h tmp/old/core/roscpp/include/ros/transport/transport_udp.h
35,36d34
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
43a42
> #include <boost/random.hpp>
45d43
< #ifndef WIN32
47d44
< #endif //WIN32
108a106,110
>   /**
>    * \brief Get a unique connection ID
>    */
>   int generateConnectionId() {return gen_();}
> 
115,116d116
<   virtual void enableRead();
<   virtual void disableRead();
140a141,145
>   /**
>    * \brief Enables reading on our socket
>    */
>   void enableRead();
> 
158a164,165
>   boost::rand48 gen_;
> 
166,171c173
<   uint8_t* data_buffer_;
<   uint8_t* data_start_;
<   uint32_t data_filled_;
< 
<   uint8_t* reorder_buffer_;
<   uint8_t* reorder_start_;
---
>   uint8_t *reorder_buffer_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport_publisher_link.h tmp/old/core/roscpp/include/ros/transport_publisher_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
33,36d30
< #ifdef WIN32
< #include <winsock2.h>
< #endif //WIN32
< 
38,40d31
< #include "connection.h"
< 
< #include "ros/defines.h"
52,53d42
< class WallTimerEvent;
< 
58c47
< class ROS_EXPORT TransportPublisherLink : public PublisherLink
---
> class TransportPublisherLink : public PublisherLink
73c62
<   void onConnectionDropped(const ConnectionPtr& conn, Connection::DropReason reason);
---
>   void onConnectionDropped(const ConnectionPtr& conn);
79c68
<   virtual void handleMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual void handleMessage(const boost::shared_array<uint8_t>& buffer, size_t num_bytes);
85,86d73
<   void onRetryTimer(const ros::WallTimerEvent&);
< 
88,93d74
< 
<   int32_t retry_timer_handle_;
<   bool needs_retry_;
<   WallDuration retry_period_;
<   WallTime next_retry_;
<   bool dropping_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/transport_subscriber_link.h tmp/old/core/roscpp/include/ros/transport_subscriber_link.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
34,37d31
< #include <boost/signals/connection.hpp>
< 
< #include "ros/defines.h"
< 
44c38
< class ROS_EXPORT TransportSubscriberLink : public SubscriberLink
---
> class TransportSubscriberLink : public SubscriberLink
56c50,51
<   virtual void enqueueMessage(const SerializedMessage& m, bool ser, bool nocopy);
---
>   virtual bool publish(const Message& m);
>   virtual void enqueueMessage(const SerializedMessage& m);
71d65
<   boost::signals::connection dropped_conn_;
Only in tmp/old/core/roscpp/include/ros/: types.h
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/wall_timer.h tmp/old/core/roscpp/include/ros/wall_timer.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
36,37d33
< #include "ros/defines.h"
< 
49c45
< class ROS_EXPORT WallTimer
---
> class WallTimer
71,75d66
<   /**
<    * \brief Set the period of this timer
<    */
<   void setPeriod(const WallDuration& period);
< 
97c88
<   class ROS_EXPORT Impl
---
>   class Impl
105d95
<     void setPeriod(const WallDuration& period);
116c106
<     VoidConstWPtr tracked_object_;
---
>     VoidWPtr tracked_object_;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/wall_timer_options.h tmp/old/core/roscpp/include/ros/wall_timer_options.h
72c72
<   VoidConstPtr tracked_object;
---
>   VoidPtr tracked_object;
diff -r -x .svn tmp/msvc/core/roscpp/include/ros/xmlrpc_manager.h tmp/old/core/roscpp/include/ros/xmlrpc_manager.h
28,29d27
< /* Initial WIN32 port by Hozefa Indorewala, Robotics Equipment Corporation GmbH, www.servicerobotics.eu */
< 
44d41
< #include "ros/defines.h"
47a45
> 
53,55c51,53
< ROS_EXPORT XmlRpc::XmlRpcValue responseStr(int code, const std::string& msg, const std::string& response);
< ROS_EXPORT XmlRpc::XmlRpcValue responseInt(int code, const std::string& msg, int response);
< ROS_EXPORT XmlRpc::XmlRpcValue responseBool(int code, const std::string& msg, bool response);
---
> XmlRpc::XmlRpcValue responseStr(int code, const std::string& msg, const std::string& response);
> XmlRpc::XmlRpcValue responseInt(int code, const std::string& msg, int response);
> XmlRpc::XmlRpcValue responseBool(int code, const std::string& msg, bool response);
95c93
< class ROS_EXPORT XMLRPCManager
---
> class XMLRPCManager
